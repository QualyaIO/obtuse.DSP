
/* Code automatically generated by Vult https://github.com/modlfo/vult */
#include "utils.h"

void utils_Trigg__ctx_type_0_init(utils_Trigg__ctx_type_0 &_output_){
   utils_Trigg__ctx_type_0 _ctx;
   bool_init_array(128,false,_ctx.triggers);
   _ctx.ticks = 0;
   _ctx.shift = 0;
   fix_init_array(128,0x0 /* 0.000000 */,_ctx.ptriggers);
   _ctx.position = 0;
   _ctx.n = 0;
   _ctx.magnitude = 0x0 /* 0.000000 */;
   _ctx.length = 0;
   _ctx.isautolength = false;
   _ctx.evolve = 0x0 /* 0.000000 */;
   _ctx.divider = 0;
   _ctx.dirty = false;
   _ctx.density = 0x0 /* 0.000000 */;
   _ctx.balance = 0x0 /* 0.000000 */;
   utils_Trigg_default(_ctx);
   _output_ = _ctx;
   return ;
}

void utils_Trigg__refresh(utils_Trigg__ctx_type_0 &_ctx){
   if(_ctx.dirty || ((_ctx.evolve > 0x0 /* 0.000000 */) && (fix_random() <= _ctx.evolve))){
      int i;
      i = 0;
      while((i < 128) && (i < _ctx.length)){
         if(_ctx.dirty || ((_ctx.magnitude > 0x0 /* 0.000000 */) && (fix_random() <= _ctx.magnitude))){
            _ctx.triggers[i] = ((_ctx.ptriggers[i] > 0x0 /* 0.000000 */) && (fix_random() <= _ctx.ptriggers[i]));
         }
         i = (1 + i);
      }
   }
   _ctx.dirty = false;
}

int utils_Trigg_process(utils_Trigg__ctx_type_0 &_ctx){
   int trig;
   trig = 0;
   _ctx.ticks = (1 + _ctx.ticks);
   if(_ctx.length > 0){
      if((_ctx.divider > 0) && (((_ctx.shift + _ctx.ticks) % _ctx.divider) == 0)){
         if(_ctx.triggers[((_ctx.n + _ctx.position) % _ctx.length)]){
            trig = 1;
         }
         _ctx.n = (1 + _ctx.n);
      }
      if((_ctx.ticks % _ctx.divider) == 0){
         _ctx.ticks = 0;
      }
      if((_ctx.n % _ctx.length) == 0){
         utils_Trigg__refresh(_ctx);
         _ctx.n = 0;
      }
   }
   return trig;
}

void utils_Trigg__recompute(utils_Trigg__ctx_type_0 &_ctx){
   fix16_t mod;
   mod = 0x0 /* 0.000000 */;
   mod = fix_div(0x10000 /* 1.000000 */,_ctx.density);
   fix16_t max_p;
   max_p = 0x10000 /* 1.000000 */;
   fix16_t min_p;
   min_p = 0x0 /* 0.000000 */;
   if((mod > 0x10000 /* 1.000000 */) && (_ctx.length > 0)){
      fix16_t fnbplus;
      fnbplus = fix_mul(_ctx.density,int_to_fix(_ctx.length));
      int nbplus;
      nbplus = fix_to_int(fnbplus);
      if((fnbplus % 0x10000 /* 1.000000 */) > 0x200 /* 0.007812 */){
         nbplus = (1 + nbplus);
      }
      int nbminus;
      nbminus = (_ctx.length + (- nbplus));
      fix16_t modp;
      modp = fix_div(int_to_fix(nbplus),int_to_fix(_ctx.length));
      if(modp >= _ctx.density){
         max_p = fix_div(fix_mul(_ctx.density,int_to_fix(_ctx.length)),int_to_fix(nbplus));
      }
      else
      {
         min_p = fix_div(((- int_to_fix(nbplus)) + fix_mul(_ctx.density,int_to_fix(_ctx.length))),int_to_fix(nbminus));
      }
   }
   int imod;
   imod = fix_to_int(mod);
   fix16_t accmod;
   accmod = 0x0 /* 0.000000 */;
   int i;
   i = 0;
   int ci;
   ci = 0;
   uint8_t upmod;
   upmod = false;
   while((i < 128) && (i < _ctx.length)){
      if(imod > 0){
         if(accmod >= 0xfe00 /* 0.992188 */){
            imod = (1 + fix_to_int(mod));
            accmod = (-0x10000 /* -1.000000 */ + accmod);
            upmod = true;
         }
         if((ci % imod) == 0){
            _ctx.ptriggers[i] = (_ctx.density + fix_mul(_ctx.balance,(max_p + (- _ctx.density))));
            if(upmod){
               imod = fix_to_int(mod);
               upmod = false;
            }
            ci = 0;
            accmod = (accmod + (mod % 0x10000 /* 1.000000 */));
         }
         else
         {
            _ctx.ptriggers[i] = (_ctx.density + (- fix_mul(_ctx.balance,(_ctx.density + (- min_p)))));
         }
      }
      else
      {
         _ctx.ptriggers[i] = _ctx.density;
      }
      ci = (1 + ci);
      i = (1 + i);
   }
}

int utils_Trigg__getAutolength(utils_Trigg__ctx_type_0 &_ctx){
   if(_ctx.density <= 0x0 /* 0.000000 */){
      return 0;
   }
   fix16_t mod;
   mod = fix_div(0x10000 /* 1.000000 */,_ctx.density);
   fix16_t autolength;
   autolength = fix_floor(mod);
   int iautolength;
   iautolength = fix_to_int(autolength);
   fix16_t mine;
   mine = 0x200 /* 0.007812 */;
   if((mod % 0x10000 /* 1.000000 */) > mine){
      autolength = fix_mul(mod,fix_div(0x10000 /* 1.000000 */,(mod % 0x10000 /* 1.000000 */)));
      if((autolength % 0x10000 /* 1.000000 */) > mine){
         iautolength = fix_to_int((0x10000 /* 1.000000 */ + autolength));
      }
      else
      {
         iautolength = fix_to_int(autolength);
      }
   }
   return iautolength;
}

uint8_t utils_Trigg__applyLength(utils_Trigg__ctx_type_0 &_ctx, int newLength){
   newLength = int_clip(newLength,0,128);
   if(newLength != _ctx.length){
      _ctx.length = newLength;
      utils_Trigg__recompute(_ctx);
      _ctx.dirty = true;
      if(_ctx.length <= _ctx.n){
         utils_Trigg_restartLoop(_ctx);
      }
      else
      {
         utils_Trigg__refresh(_ctx);
      }
      return true;
   }
   return false;
}

void utils_Trigg_setLength(utils_Trigg__ctx_type_0 &_ctx, int newLength){
   newLength = int_clip(newLength,0,128);
   if((newLength == 0) && bool_not(_ctx.isautolength)){
      _ctx.isautolength = true;
      newLength = utils_Trigg__getAutolength(_ctx);
   }
   else
   {
      if((newLength > 0) && _ctx.isautolength){
         _ctx.isautolength = false;
      }
   }
   utils_Trigg__applyLength(_ctx,newLength);
}

void utils_Trigg_setBalance(utils_Trigg__ctx_type_0 &_ctx, fix16_t newBalance){
   newBalance = fix_clip(newBalance,0x0 /* 0.000000 */,0x10000 /* 1.000000 */);
   if(newBalance != _ctx.balance){
      _ctx.balance = newBalance;
      utils_Trigg__recompute(_ctx);
      _ctx.dirty = true;
      utils_Trigg__refresh(_ctx);
   }
}

void utils_Trigg_setDensity(utils_Trigg__ctx_type_0 &_ctx, fix16_t newDensity){
   newDensity = fix_clip(newDensity,0x0 /* 0.000000 */,0x10000 /* 1.000000 */);
   if(newDensity != _ctx.density){
      _ctx.density = newDensity;
      uint8_t update;
      update = true;
      if(_ctx.isautolength){
         update = bool_not(utils_Trigg__applyLength(_ctx,utils_Trigg__getAutolength(_ctx)));
      }
      if(update){
         utils_Trigg__recompute(_ctx);
         _ctx.dirty = true;
         utils_Trigg__refresh(_ctx);
      }
   }
}

void utils_Trigg_default(utils_Trigg__ctx_type_0 &_ctx){
   _ctx.divider = 1;
   _ctx.length = 16;
   _ctx.density = 0x8000 /* 0.500000 */;
   _ctx.balance = 0x8000 /* 0.500000 */;
   _ctx.evolve = 0x3333 /* 0.200000 */;
   _ctx.magnitude = 0x4000 /* 0.250000 */;
   utils_Trigg__recompute(_ctx);
   _ctx.dirty = true;
   utils_Trigg__refresh(_ctx);
}

void utils_Clock__ctx_type_4_init(utils_Clock__ctx_type_4 &_output_){
   utils_Clock__ctx_type_4 _ctx;
   _ctx.swing = 0x0 /* 0.000000 */;
   _ctx.subSize = 0;
   _ctx.pos = 0;
   _ctx.orderMix = false;
   _ctx.lastBeat = 0x0 /* 0.000000 */;
   _ctx.init = false;
   _ctx.ibiB = 0x0 /* 0.000000 */;
   _ctx.ibiA = 0x0 /* 0.000000 */;
   _ctx.ibi = 0x0 /* 0.000000 */;
   _ctx.groupSize = 0;
   _ctx.groupRatio = 0x0 /* 0.000000 */;
   _ctx.bpm = 0x0 /* 0.000000 */;
   utils_Clock_default(_ctx);
   _output_ = _ctx;
   return ;
}

int utils_Clock_process(utils_Clock__ctx_type_4 &_ctx, fix16_t time){
   int trigger;
   trigger = 0;
   if(bool_not(_ctx.init) || (time < _ctx.lastBeat)){
      _ctx.init = true;
      _ctx.lastBeat = time;
      trigger = 1;
      _ctx.pos = 1;
      _ctx.ibi = _ctx.ibiA;
   }
   else
   {
      if((time + (- _ctx.lastBeat)) >= _ctx.ibi){
         _ctx.lastBeat = (_ctx.ibi + _ctx.lastBeat);
         if((bool_not(_ctx.orderMix) && (_ctx.pos < _ctx.subSize)) || (_ctx.orderMix && ((((_ctx.pos / 2) < _ctx.subSize) && ((_ctx.pos % 2) == 0)) || ((_ctx.pos / 2) > (_ctx.groupSize + (- _ctx.subSize)))))){
            _ctx.ibi = _ctx.ibiA;
            if(_ctx.pos == 0){
               trigger = 1;
            }
            else
            {
               trigger = 2;
            }
         }
         else
         {
            _ctx.ibi = _ctx.ibiB;
            trigger = 3;
         }
         _ctx.pos = (1 + _ctx.pos);
         _ctx.pos = (_ctx.pos % _ctx.groupSize);
      }
   }
   return trigger;
}

void utils_Clock__recompute(utils_Clock__ctx_type_4 &_ctx){
   _ctx.subSize = int_clip(fix_to_int(fix_mul(_ctx.groupRatio,int_to_fix((1 + _ctx.groupSize)))),1,((-1) + _ctx.groupSize));
   fix16_t bibi;
   bibi = fix_div(0x3c0000 /* 60.000000 */,_ctx.bpm);
   if(_ctx.swing <= 0x8000 /* 0.500000 */){
      _ctx.ibiA = fix_clip((fix_mul(_ctx.swing,bibi) << 1),0x83 /* 0.002000 */,bibi);
      _ctx.ibiB = fix_div(((- fix_mul(_ctx.ibiA,int_to_fix(_ctx.subSize))) + fix_mul(bibi,int_to_fix(_ctx.groupSize))),int_to_fix((_ctx.groupSize + (- _ctx.subSize))));
   }
   else
   {
      _ctx.ibiB = fix_clip((fix_mul(bibi,(0x10000 /* 1.000000 */ + (- _ctx.swing))) << 1),0x83 /* 0.002000 */,bibi);
      _ctx.ibiA = fix_div(((- fix_mul(_ctx.ibiB,int_to_fix((_ctx.groupSize + (- _ctx.subSize))))) + fix_mul(bibi,int_to_fix(_ctx.groupSize))),int_to_fix(_ctx.subSize));
   }
}

void utils_Clock_setBPM(utils_Clock__ctx_type_4 &_ctx, fix16_t newBPM){
   newBPM = fix_clip(newBPM,0x83 /* 0.002000 */,0x75300000 /* 30000.000000 */);
   if(newBPM != _ctx.bpm){
      _ctx.bpm = newBPM;
      utils_Clock__recompute(_ctx);
   }
}

void utils_Clock_setGroupSize(utils_Clock__ctx_type_4 &_ctx, int newGroupSize){
   newGroupSize = int_clip(newGroupSize,2,128);
   if(newGroupSize != _ctx.groupSize){
      _ctx.groupSize = newGroupSize;
      utils_Clock__recompute(_ctx);
      _ctx.pos = (_ctx.pos % _ctx.groupSize);
   }
}

void utils_Clock_setGroupRatio(utils_Clock__ctx_type_4 &_ctx, fix16_t newGroupRatio){
   newGroupRatio = fix_clip(newGroupRatio,0x0 /* 0.000000 */,0x10000 /* 1.000000 */);
   if(newGroupRatio != _ctx.groupRatio){
      _ctx.groupRatio = newGroupRatio;
      utils_Clock__recompute(_ctx);
   }
}

void utils_Clock_setSwing(utils_Clock__ctx_type_4 &_ctx, fix16_t newSwing){
   newSwing = fix_clip(newSwing,0x0 /* 0.000000 */,0x10000 /* 1.000000 */);
   if(_ctx.swing != newSwing){
      _ctx.swing = newSwing;
      utils_Clock__recompute(_ctx);
   }
}


