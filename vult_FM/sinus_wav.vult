
// note that wavetable should be big enough to avoid fixed float limits upon later computations (let say at least 100)
external sin_wave(channel:int, index:int) : real @[wave(channels=1, file="sinus_8k.wav")];

fun index() {
   mem i = (i + 1) % sin_wave_samples();
   return i;
}

fun process() {
   // audio sampling rate
   mem fs: real;
   // sinus frequency
   mem freq: real;
   // [0..8k[ in the wavetable
   mem phase: real;
   // going that much through wavetable at each call
   mem step: real;

   // advance time
   phase = phase + step;
   phase = phase % real(sin_wave_samples());
   // loop in sample
   return sin_wave(0, int(phase));
}
// size of wavetable (int)
and getSize() {
    return sin_wave_samples();
}
// manually setting the step between each call, overriding frequency and samplerate for for effiency at times
// for outside, expect step between 0 and size
and setStep(newStep:real) {
    // do not check, modulo will be applied later
    step = newStep;
}
// called internally when Samplerate or frequency is altered
and updateStep() {
    // base for computing step
    mem stepRatio;
    // both for efficiency and because we don't want any result to be outside [1/32767 .. 32767] to avoid fixed float limits we compute step in two... steps
   _ = setStep(stepRatio*freq);
}
// seter for parameters. expect values of desired frequency and current sampring rate in kHz to avoid fixed float limits ([1/32767 ..32767]... probably)
and setSamplerate(newFs:real) {
   if (newFs > 0.0) {
      fs = newFs;
      // update ratio when we update sampling rate
      stepRatio = real(getSize()) / fs;
   }
   _ = updateStep();
}
and setFrequency(newFreq:real) {
   freq = newFreq;
   step = stepRatio*freq;
   //_ = updateStep();
}
and default() @[init] {
   // default sampling rate (in kHz)
   _ = setSamplerate(44.1);
   // default frequency (in kHz)
   _ = setFrequency(0.440);
}