
// FM with 2 operators, phase modulation, monophonic

// TODO: should we reset phase on noteoff, keep processing with env 0?

// For future reference, note that using at least a temp variable in process() force vult to put that in cpp and halves computation times (???)


// FIXME: obvious duplicated code
fun process() {
    // audio sampling rate
    mem fs: real;
    
    // prec-computed to speedup computations
    mem carrier_half_phase;

    // reduce cost of envelopes, only computes once in a while
    mem env_decimation_factor;
    mem carrier_env;
    mem modulator_env;
    // number of iteration of this loop, for decimation
    mem n;

    //  current gate (can be > 1 if several notes are held)
    mem gate : bool;

    n = n + 1;
    val update_env:bool = true;
    if (env_decimation_factor > 0) {
       update_env = n % env_decimation_factor == 0;
    }

    // output value -- need to be explicitely initialized otherwise migth be random (?) producing audible clicks
    val carrier_val = 0.0;
    // retrieve main envelope
    if (update_env) {
       carrier_env = carrieradsr:ADSR.process(gate);
    }

    // only going forward if we got sound on the output
    if (carrier_env > 0.0) {
       if (update_env) {
           modulator_env = modulatoradsr:ADSR.process(gate);
       }
       // apply to wavetables
       val carrier_phase = 0.0;
       // only modulate if we got level on modulator
       if (modulator_env > 0.0) {
          val modulator_val = (modulator:OSC.process() + 1.0) * modulator_env;
	  carrier_phase = modulator_val * carrier_half_phase;
       }
       // modulate the (base) phase of the carrier
       _ = carrier:OSC.setPhase(carrier_phase);
       carrier_val = carrier:OSC.process() * carrier_env ;
    }

    return carrier_val;
}

// update the buffer, to be fetch afterward
and process_buffer(nb: int) {
    mem buffer;
    mem buffer_modulator;
    mem buffer_carrier_phase;
    nb = clip(nb, 0, size(buffer));
    if (nb == 0) {
       nb = size(buffer);
    }
    // amount of phase modulation
    mem level;

    // buffers for envelops, decimated and the full 
    mem buffer_carrier_env_short;
    mem buffer_modulator_env_short;
    mem buffer_carrier_env;
    mem buffer_modulator_env;

    // compute number of samples for this buffer's decimation
    val nb_env = (n + nb) / env_decimation_factor;

    // retrieve envelopes
    if (nb_env > 0) {
       _ = carrieradsr:ADSR.process_buffer(gate, nb_env);
       _ = carrieradsr:ADSR.copyTo(buffer_carrier_env_short, nb_env);
       _ = modulatoradsr:ADSR.process_buffer(gate, nb_env);
       _ = modulatoradsr:ADSR.copyTo(buffer_modulator_env_short, nb_env);
    }

    // expand carrier envelop and retrieve to full version
    // FIXME: do not do that at all if decimation 1
    val i = 0;
    val i_env = 0;
    while (i < nb) {
       // advance and update envelope
       n = (n + 1) % env_decimation_factor;
       if (n == 0) {
          modulator_env = buffer_modulator_env_short[i_env];
	  carrier_env = buffer_carrier_env_short[i_env];
          i_env = i_env + 1;
       }
       buffer_modulator_env[i] = modulator_env;
       buffer_carrier_env[i] = carrier_env;
       i = i + 1;
    }


    // retrieve modulation
    // FIME: can we here find a way to not calling when the corresponding envelope is 0?
    _ = modulator:OSC.process_buffer_simple(nb, buffer_modulator_env);
    _ = modulator:OSC.copyTo(buffer_modulator, nb);

    // apply to carrier
    // FIXME: pass volume directly?
    _ = carrier:OSC.process_buffer(nb, buffer_carrier_env, buffer_carrier_phase, level);
    _ = carrier:OSC.copyTo(buffer, nb);
}
and getBuffer() {
   return buffer;
}
// copy output values to dest buffer
and copyTo(oBuffer:array(real, 256), nb: int){
   // ensure we won't overflow
   val min_size = size(oBuffer);
   if (size(buffer) < min_size) {
      min_size = size(buffer);
   }
   nb = clip(nb, 0, min_size);
   if (nb == 0) {
      nb = min_size;
   }
   val i = 0;
   while (i < nb) {
      oBuffer[i] = buffer[i];
      i = i + 1;
   }
}
and setSamplerate(newFs:real) {
   if (newFs > 0.0) {
      fs = newFs;
   }
   _ = carrier:OSC.setSamplerate(fs);
   _ = modulator:OSC.setSamplerate(fs);

    // config for ADSR
    val ADSR_fs = fs;
    if (env_decimation_factor > 0) {
       ADSR_fs = fs / real(env_decimation_factor);
    }
    _ = carrieradsr:ADSR.setSamplerate(ADSR_fs);
    _ = modulatoradsr:ADSR.setSamplerate(ADSR_fs);
}
// ratio for each operator. Keep in mind the max effective frequency, below samplingrate/2!
and setCarrierRatio(ratio: real) {
   mem carrierRatio = ratio;
}
and setModulatorRatio(ratio: real) {
   mem modulatorRatio = ratio;
}
// effect of modulator [0..1]
and setModulatorLevel(newLevel: real) {
    level = newLevel;
    // directly manipulating the phase amount
    carrier_half_phase = real(carrier:OSC.getSize()) / 2.0 * level;
}
// should be 0..nquist, in kHz
and setFrequency(freq: real) {
    _ = carrier:OSC.setFrequency(freq * carrierRatio);
    _ = modulator:OSC.setFrequency(freq * modulatorRatio);
}

// set polpyphonic (true flag) or monophonic (false flag)
// monophonic: will get back to former notes, if any, upon note off
// polyphonic: does try to get back to held notes frequencies
and setPoly(flag: bool) {
   _ = playingnotes:Notes.setPoly(flag);
}

// midi-like interface

// beginning of a note -- will effectively ignore duplicated noteOn for same note
// we don't check velocity, yet
and noteOn(note:int, velocity:int, channel:int){
   // only 128 midi notes
   note = clip(note, 0, 127);
   // only acts if action taken into account
   if (playingnotes:Notes.noteOn(note, velocity, channel)) {
       // set frequency... should we reset phase somehow? artifacts upon first tests
       _ = setFrequency(Util.noteToFrequency(note));
       // gate, no mater what
       gate = true;
   }
}
// note off whatever the channel, back to frequency of last still active note if any
and noteOff(note:int, channel:int) {
   // only 128 midi notes
   note = clip(note, 0, 127);
   // only acts if action taken into account
   if (playingnotes:Notes.noteOff(note, channel)) {
      // still gate on-going if there are note held, and switch to last
      if (playingnotes:Notes.nbNotes() > 0){
         val last_played = playingnotes:Notes.lastNote();
	 // check we do have a note -- and that it's in range
         if (last_played > 0 && last_played <= 128) {
            _ = setFrequency(Util.noteToFrequency(last_played - 1));
         }
      } else {
         gate = false;
      }
   }
}

// to be called on start
and default() @[init] {
    // will copy new arrays
    buffer = Util.buffer();
    buffer_modulator = Util.buffer();
    buffer_carrier_env_short = Util.buffer();
    buffer_modulator_env_short = Util.buffer();
    buffer_carrier_env = Util.buffer();
    buffer_modulator_env = Util.buffer();
    buffer_carrier_phase = Util.buffer();

    // should be a divisor of sample rate
    env_decimation_factor = 3;

    // init used items
    // FIXME: not sure why if @init is set
    _ = carrier:OSC.default();
    _ = modulator:OSC.default();
    _ = carrieradsr:ADSR.default();
    _ = modulatoradsr:ADSR.default();

    // default sampling rate (in kHz)
    _ = setSamplerate(44.100);
    
    // config for operators
    _ = setCarrierRatio(1.0);
    _ = setModulatorRatio(2.0);
    _ = setModulatorLevel(0.1);
    // sarting with LA
    _ = setFrequency(0.440);

    // monophonic by default
    _ = playingnotes:Notes.default();
    _ = setPoly(false);
}