
// reading slices of samples for drums. Using linear interpolation to adjust for sampling rate and pitch.
// 12 slices, normal speed at C4-G5, then adjust each slice an octave up or down. Each new note replace immediately the previous one.

// TODO: kill on noteOff

external drumkit(channel:int, index:int) : real @[wave(channels=1, file="808.wav")];

// return value for current wavetable (first channel hard-coded), between [0..sample size[
fun getSample(index: int) {
  return drumkit(0, index);
}

and process() {
  // absolutely needs init to set that
  mem size: int;
  // start and end positions for slices
  mem slices_start, slices_end;
  // current slice playing [0..11], out of bound to stop playing
  mem slice: int;
  // using integer "base position" float position to overcome limitation of fixed point
  mem posBase: int;
  mem pos: real;
  // how much we jump each step
  mem step: real;

  val value = 0.0;

  // advance time, keep range in check here to maximize precision
  pos = pos + step;
  while (pos >= 1024.0) {
    posBase = posBase + 1024;
    pos = pos - 1024.0;
  }

  val idx = posBase + int(pos);
  // will stop and reset note once reach the end of file
  if (idx >= size) {
    slice = -1;
    posBase = 0;
    pos = 0.0;
  }

  if (slice >= 0 && slice <= size(slices_start)) {

    // stop and reset once reached and of sample
    if (idx >= slices_end[slice]) {
      slice = -1;
      posBase = 0;
      pos = 0.0;
    } else {
      value = getSample(idx) + (pos % 1.0) * (getSample(idx+1) - getSample(idx));
    }

  }

  return value;
}


and process_bufferTo(nb: int, oBuffer: array(real, 256)) {
  nb = clip(nb, 0, size(oBuffer));
  if (nb == 0) {
     nb = size(oBuffer);
  }

  val value, i;

  while (i < nb) {
    value = 0.0;
    // advance time, keep range in check here to maximize precision
    pos = pos + step;
    while (pos >= 1024.0) {
      posBase = posBase + 1024;
      pos = pos - 1024.0;
    }

    val idx = posBase + int(pos);
    // will stop and reset note once reach the end of file
    if (idx >= size) {
      slice = -1;
      posBase = 0;
      pos = 0.0;
    }
  
    if (slice >= 0 && slice <= size(slices_start)) {
  
      // stop and reset once reached and of sample
      if (idx >= slices_end[slice]) {
        slice = -1;
        posBase = 0;
        pos = 0.0;
      } else {
        value = getSample(idx) + (pos % 1.0) * (getSample(idx+1) - getSample(idx));
      }
    }
    oBuffer[i] = value;
    i = i + 1;
  }
}

// retrocompatibility: using inner buffer
and process_buffer(nb: int) {
  mem buffer_o;
  _ = process_bufferTo(nb, buffer_o);
}

// called internally when Samplerate or note is altered
and updateStep() {
  // base for computing step
  mem noteRatio: real;
  mem fsRatio: real;
  // both for efficiency and because we don't want any result to be outside [1/32767 .. 32767] to avoid fixed float limits we compute step in two... steps
  step = noteRatio*fsRatio;
}

// passes start and stop arrays for slices. arrays must have same size, and same size as inner slices_start and slices_end arrays. For a slice to be updated indices must be within sample size range, and for each slice start pos must be before end pos.
and setSlices(newSlicesStart: array(int, 12), newSlicesEnd: array(int, 12)) {
  if (size(newSlicesStart) == size(newSlicesEnd) && size(newSlicesStart) == size(slices_start) && size(newSlicesEnd) == size(slices_end)) {
    val i = 0;
    val s, e;
    while (i < size(newSlicesStart)) {
      s = clip(newSlicesStart[i], 0, drumkit_samples() - 1);
      e = clip(newSlicesEnd[i], 0, drumkit_samples() - 1);
      if (s <= e) {
        slices_start[i] = s;
        slices_end[i] = e;
      }
      i = i + 1;
    }
  }
}

// seter for parameters. expect values of desired frequency and current sampling rate in kHz to avoid fixed float limits ([1/32767 ..32767]... probably)
and setSamplerate(newFs:real) {
  // sample rate of the recording
  mem sampleFs;
  // audio sampling rate
  mem fs: real;
   if (newFs > 0.0) {
      fs = newFs;
      // update ratio when we update sampling rate
      fsRatio = sampleFs/fs;
   }
   _ = updateStep();
}

// number of samples (note: valid once init)
and getSampleSize() {
  return size;
}

// beginning of a note -- will effectively ignore duplicated noteOn for same note
// we don't check velocity, yet
and noteOn(note:int, velocity:int, channel:int){
  // only 128 midi notes
  note = clip(note, 0, 127);
  // root note for the 12 slices: C4
  val root = 60;
  slice = note % 12;
  // set starting position
  if (slice >= 0 && slice < size(slices_start)) {
    posBase = slices_start[slice];
    pos = 0.0;
  }

  // find octave compared to root note, 
  val slice_root = note - slice;
  // use ratio of note rather than freq to be more precise, +1 octave (12 semitones) doubles speed, -1 octave halves it
  val log_two = log10(2.0)/log10(exp(1.0)); // so that vultc replace with result of log(2)
  val octave = real(slice_root-root)/12.0;
  noteRatio = exp(log_two * octave);
  _ = updateStep();
}

and noteOff(note:int, channel:int) {
}

and default() @[init] {
  size = drumkit_samples();
  // keep track of slices
  mem slices_start: array(int, 12);
  mem slices_end: array(int, 12);
  // defaults for current sample and DSP
  sampleFs = 30.0;
  _ = setSamplerate(44.1);
  // set default slices
  _ = setSlices(
                [0, 11500, 22000, 26000, 28800, 45600, 46550, 49000, 50400, 61000, 78100, 83600],
                [10000, 21500, 25500, 28500, 45500, 46500, 48550, 50100, 60000, 78000, 83500, 107000]
  );
  // will copy a new array
  mem buffer_o = Util.buffer();
}
