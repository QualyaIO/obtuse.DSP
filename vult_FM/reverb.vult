
// Attempt at creating reverb using the heavily-used Schroeder reverb

// Note: 
// Numbers from Schroeder reverberator SATREV, see Figure 3.6 https://ccrma.stanford.edu/~jos/pasp/Example_Schroeder_Reverberators.html 
// comb0: 0.827 / 778 samples
// comb1: 0.805 / 901 samples
// comb2: 0.783 / 1011 samples
// comb3: 0.764 / 1123 sample
// allpass0: 0.7 / 125 samples
// allpass0: 0.7 / 42 samples

fun process(sample: real) {
  // average comb filters' output
  val combs_filter = (comb0:CombFB.process(sample) + comb1:CombFB.process(sample) + comb2:CombFB.process(sample) + comb3:CombFB.process(sample)) * 0.25;
  // apply allpass in series
  return allpass1:Allpass.process(allpass0:Allpass.process(combs_filter));
}

// pass-down parameters to combfilters
// In theory [0..1], but will start to degenerate below 0.127 as it won't be sufficient for all filters, some will be default to 0.
and setDecay(newDecay: real) {
  _ = comb0:CombFB.setDecay(newDecay);
  _ = comb1:CombFB.setDecay(newDecay - 0.022);
  _ = comb2:CombFB.setDecay(newDecay - 0.044);
  _ = comb3:CombFB.setDecay(newDecay - 0.063);
  // fixed value for both all-pass??
  _ = allpass0:Allpass.setDecay(0.7);
  _ = allpass1:Allpass.setDecay(0.7);
}

// note: filters will update themselves the corresponding delay, no need to compute again
// WARNING: will *not* update delays in ms when this is changed, hence to be called first
and setSamplerate(newFs:real) {
  mem fs;
  if (newFs > 0.0) {
     fs = newFs;
  } else {
     fs = 44.1;
  }
  _ = comb0:CombFB.setSamplerate(newFs);
  _ = comb1:CombFB.setSamplerate(newFs);
  _ = comb2:CombFB.setSamplerate(newFs);
  _ = comb3:CombFB.setSamplerate(newFs);
  _ = allpass0:Allpass.setSamplerate(newFs);
  _ = allpass1:Allpass.setSamplerate(newFs);
}

// In theory [0.. max buffer/fs] but will start to degenerate below a certain threshold as some delays will be zeroed (below ~ 7.83ms at 44100hz)
// FIXME: this is actually wrong, should re-compute delay to be primed among them instead of keeping same spacing
and setDelayms(delayms: real) {
  // convert to delay in samples
  val delay = int(fs * delayms);
  _ = comb0:CombFB.setDelay(delay - 345);
  _ = comb1:CombFB.setDelay(delay - 222);
  _ = comb2:CombFB.setDelay(delay - 112);
  _ = comb3:CombFB.setDelay(delay);
  // fixed value for both all-pass??
  _ = allpass0:Allpass.setDelay(125);
  _ = allpass1:Allpass.setDelay(42);
}
and default() @[init] {
  _ = setSamplerate(44.100);
  // for default parameters found in litteratures
  _ = setDelayms(1123.0/44.1);
  _ = setDecay(0.827);
}
