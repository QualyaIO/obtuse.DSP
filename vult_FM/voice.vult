
// abstract handling of polyvoice synths (e.g. FM).
// Very conservative concerning the volume, will each voice will have a fraction of the max amplitude.
// Note: does not take midi channel into account at this level
// TODO: back to monophonic if number of voices is 1

// synth list:
//    0: FM

// retrieve sample from a specific voice
fun getSample(voice: int) {
   // what synth is currently selected
   mem synth;
   // how many voices we support at the moment?
   mem number_voices;

   if (voice < number_voices) {
       if (voice == 0) {
           if (synth == 0) {
              return voice0FM:FM.process();
	   }
       }
       else if (voice == 1) {
           if (synth == 0) {
              return voice1FM:FM.process();
	   }
       }
       else if (voice == 2) {
           if (synth == 0) {
              return voice2FM:FM.process();
	   }
       }
       else if (voice == 3) {
           if (synth == 0) {
              return voice3FM:FM.process();
	   }
       }

   }
   return 0.0;
}

// run buffer for specified voice (buffered version of getSample), filling specified buffer
and runVoice(voice: int, nb: int, buff: array(real, 256)) {
   if (voice < number_voices) {
       if (voice == 0) {
           if (synth == 0) {
   	      _ = voice0FM:FM.process_buffer(nb);
              _ = voice0FM:FM.copyTo(buff, nb);
	   }
       }
       else if (voice == 1) {
           if (synth == 0) {
   	      _ = voice1FM:FM.process_buffer(nb);
              _ = voice1FM:FM.copyTo(buff, nb);
	   }
       }
       else if (voice == 2) {
           if (synth == 0) {
   	      _ = voice2FM:FM.process_buffer(nb);
              _ = voice2FM:FM.copyTo(buff, nb);
	   }
       }
       else if (voice == 3) {
           if (synth == 0) {
	      _ = voice3FM:FM.process_buffer(nb);
	      _ = voice3FM:FM.copyTo(buff, nb);
	   }
       }
   }
}


// retrieve sample from all voices, mix
and process() {
   // what synth is currently selected
   mem synth;

   // If voices are currently playng on not -- and max number of voices
   mem voices;
   // how many voices we support at the moment?
   mem number_voices;
   // to speedup, corresponding ratio per voice
   mem voices_ratio;
   // what voice (if any) number are associated to
   mem notes;

   // output sample
   val value = 0.0;

   val i = 0;
   // accumulate all voices
   while (i < number_voices) {
      value = value + getSample(i);
      i = i + 1;
   }
   // normalise
   return value * voices_ratio;
}

// one buffer for all voice
and process_buffer(nb: int) {
   // here used as temporary buffer to hold each voice
   mem buffer_v0;
   // output values
   mem buffer_o;
   nb = clip(nb, 0, size(buffer_o));
   if (nb == 0) {
      nb = size(buffer_o);
   }
   // run all voices and add to output buffer
   val v = 0;
   val i = 0;
   while (v < number_voices) {
      _ = runVoice(v, nb, buffer_v0);
      i = 0;
      while (i < nb) {
         buffer_o[i] = buffer_o[i] + buffer_v0[i];
         i = i + 1;
      }
      v = v + 1;
   }
   // scale down
   i = 0;
   while (i < nb) {
      buffer_o[i] = buffer_o[i] * voices_ratio;
      i = i + 1;
   }
}

// several buffer
and process_buffer_alt(nb: int) {
   // temporary buffer to hold each voice
   mem buffer_v0, buffer_v1, buffer_v2, buffer_v3;
   // output values
   mem buffer_o;
   nb = clip(nb, 0, size(buffer_o));
   if (nb == 0) {
      nb = size(buffer_o);
   }
   _ = runVoice(0, nb, buffer_v0);
   _ = runVoice(1, nb, buffer_v1);
   _ = runVoice(2, nb, buffer_v2);
   _ = runVoice(3, nb, buffer_v3);
   val i = 0;
   while (i < nb) {
      buffer_o[i] = (buffer_v0[i] + buffer_v1[i] + buffer_v2[i] + buffer_v3[i]) * voices_ratio;
      i = i + 1;
   }
}

// send note on to selected inactive voice
// Note: should be call internally, DON'T update inner states, only forward info
and _sendNoteOn(voice:int, note:int, velocity: int, channel:int) {
   // check against max size of voices, not number_voices, in case we try to fix something
   if (voice >= 0 && voice < size(voices)) {
       // a tad tedious, as many context as we handle voices, and test all possible synth
       if (voice == 0) {
           if (synth == 0) {
              _ = voice0FM:FM.noteOn(note, velocity, channel);
	   }
       }
       else if (voice == 1) {
           if (synth == 0) {
              _ = voice1FM:FM.noteOn(note, velocity, channel);
	   }
       }
       else if (voice == 2) {
           if (synth == 0) {
              _ = voice2FM:FM.noteOn(note, velocity, channel);
	   }
       }
       else if (voice == 3) {
           if (synth == 0) {
              _ = voice3FM:FM.noteOn(note, velocity, channel);
	   }
       }
   }
}

// send note off to selected active voice
// Note: should be call internally, DON'T update inner states, only forward info
and _sendNoteOff(voice:int, note:int, channel:int) {
   // check against max size of voices, not number_voices, in case we try to fix something
   if (voice >= 0 && voice < size(voices)) {
       // a tad tedious, as many context as we handle voices, and test all possible synth
       if (voice == 0) {
           if (synth == 0) {
              _ = voice0FM:FM.noteOff(note, channel);
	   }
       }
       else if (voice == 1) {
           if (synth == 0) {
              _ = voice1FM:FM.noteOff(note, channel);
	   }
       }
       else if (voice == 2) {
           if (synth == 0) {
              _ = voice2FM:FM.noteOff(note, channel);
	   }
       }
       else if (voice == 3) {
           if (synth == 0) {
              _ = voice3FM:FM.noteOff(note, channel);
	   }
       }
   }
}

// transmit noteOff to corresponding voice, update inner states active/inactive voice
and noteOff(note:int, channel:int) {
   // only 128 midi notes (and max voice)
   note = clip(note, 0, 127);
   // corresponding voice stored as voice+1
   val v = notes[note];
   // is this note really playing on a voice?
   if (v > 0 && v <= size(voices)) {
      // remove voice from active
      // channel 0, just because
      if (voicesactive:Notes.noteOff(v - 1, 0)) {
          // disable voice
          _ = _sendNoteOff(v - 1, note, channel);
          // update arrays
          notes[note] = 0;
	  voices[v-1] = 0;
	  // add voice to inactive (127 velocity, just because)
	  _ = voicesinactive:Notes.noteOn(v - 1, 127, 0);
      }
   }
}

// transmit noteOn to new voice (oldest inactive). If none, will turn off and steal oldest active. update inner states active/inactive voice
and noteOn(note:int, velocity:int, channel:int){
   // only 128 midi notes
   note = clip(note, 0, 127);
   // ignore note if already with a voice
   if (notes[note] <= 0) {
      // at least one free voice, take the oldest
      // todo: check both active and inactive status?
      val v = voicesinactive:Notes.firstNote();
      // no active voice, we will steal one
      if (v <= 0) {
         val active_v = voicesactive:Notes.firstNote();
	 // check we do indeed have one (the opposity would be a bug)
	 if (active_v > 0) {
	    // disable this voice (with arbitrary channel)
	    _ = noteOff(voices[active_v-1], 0);
	 }
      }
      // ne we should have at least one inactive voice
      v = voicesinactive:Notes.firstNote();
      if (v > 0) {
         // voice removed successfully from inactive ones and added to active ones (arbitrary channel 0 and velocity 127)
         if (voicesinactive:Notes.noteOff(v - 1, 0) && voicesactive:Notes.noteOn(v - 1, 127, 0)) {
	    // forward info
	    _ = _sendNoteOn(v - 1, note, velocity, channel);
            // update arrays
            notes[note] = v;
            voices[v-1] = note;
         }
      }
   }
}

// setter for the number of voices, from 0 (disable) to max size of inner buffer
and setNbVoices(nbvoices: int) {
   nbvoices = clip(nbvoices, 0, size(voices));
   // turn off voices that will be unused, highest voice first
   val i = voicesactive:Notes.nbNotes();
   while(i > nbvoices && i > 0) {
      // get note of current voice and turn it off (with arbitrary channel)
      _ = noteOff(voices[i-1], 0);
      // also remove from inactive
      _ = voicesinactive:Notes.noteOff(i - 1, 0);
      i = i - 1;
   }
   // turn on inactive voice, lowest first
   i = voicesinactive:Notes.nbNotes();
   while(i < nbvoices) {
      _ = voicesinactive:Notes.noteOn(i, 127, 0);
      i = i + 1;
   }


   number_voices = nbvoices;
   voices_ratio  = 1.0/real(number_voices);
}

// change sampling rate for current synth
and setSamplerate(newFs:real) {
   mem fs;
   if (newFs > 0.0) {
      fs = newFs;
   }
   if (synth == 0) {
      _ = voice0FM:FM.setSamplerate(fs);
      _ = voice1FM:FM.setSamplerate(fs);
      _ = voice2FM:FM.setSamplerate(fs);
      _ = voice3FM:FM.setSamplerate(fs);
  }
}

// init voices of selecetd synth (see beginning of file for list of supported)
and selectSynth(nsynth: int) {
   if (nsynth == 0) {
      nsynth = synth;
      _ = voice0FM:FM.default();
      _ = voice0FM:FM.setPoly(true);
      _ = voice1FM:FM.default();
      _ = voice1FM:FM.setPoly(true);
      _ = voice2FM:FM.default();
      _ = voice2FM:FM.setPoly(true);
      _ = voice3FM:FM.default();
      _ = voice3FM:FM.setPoly(true);
   }
   _ = setSamplerate(fs);
}

// retrieve output values from buffer
and getBuffer() {
   return buffer_o;
}
// copy output values to dest buffer
and copyTo(oBuffer:array(real, 256), nb: int){
   // ensure we won't overflow
   val min_size = size(oBuffer);
   if (size(buffer_o) < min_size) {
      min_size = size(buffer_o);
   }
   nb = clip(nb, 0, min_size);
   if (nb == 0) {
      nb = min_size;
   }
   val i = 0;
   while (i < nb) {
      oBuffer[i] = buffer_o[i];
      i = i + 1;
   }
}

and default() @[init] {
   buffer_v0 = Util.buffer();
   buffer_v1 = Util.buffer();
   buffer_v2 = Util.buffer();
   buffer_v3 = Util.buffer();
   buffer_o = Util.buffer();

   mem voices: array(int, 4);
   number_voices = if number_voices == 0 then size(voices) else number_voices;
    // which notes are active, if so to which voice? (to select voice and prune duplicated note on/off). Stores voice number + 1
   _ = setNbVoices(number_voices);
   mem notes: array(int, 128);

   // monophonic algo used to keep track of active voices...
   _ = voicesactive:Notes.default();
   _ = voicesactive:Notes.setPoly(false);
   // and same for disabled voices
   _ = voicesinactive:Notes.default();
   _ = voicesinactive:Notes.setPoly(false);

  fs = 44.100;
  // select synth, active init voices, propagate sampling rate
  _ = selectSynth(0);
}
