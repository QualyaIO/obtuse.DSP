
// wrapper to create voice from a poly synth
// Very conservative concerning the volume, will each voice will have a fraction of the max amplitude.
// Note: does not take midi channel into account at this level
// TODO: back to monophonic if number of voices is 1

// retrieve sample from all voices, mix
fun process() {
   // If voices are currently playng on not -- and max number of voices
   mem voices;
   // how many voices we support at the moment?
   mem number_voices;
   // to speedup, corresponding ratio per voice
   mem voices_ratio;
   // what voice (if any) number are associated to
   mem notes;
   // normalize: output maxed to -1 / 1 no matter the number of voices
   mem normalize;

   // output sample
   val value = 0.0;

   val i = 0;
   // accumulate all voices
   while (i < number_voices) {
      value = value + poly:Poly.getSample(i);
      i = i + 1;
   }
   // normalise
   if (normalize) {
      return value * voices_ratio;
   }
   return value;
}

// one buffer for all voice
and process_bufferTo(nb: int, oBuffer: array(real, 256)) {
   // here used as temporary buffer to hold each voice
   mem buffer_v0;
   nb = clip(nb, 0, size(oBuffer));
   if (nb == 0) {
      nb = size(oBuffer);
   }
   // run all voices and add to output buffer
   val v = 0;
   val i = 0;
   // first run to init
   if (v < number_voices) {
      _ = poly:Poly.runVoice(v, nb, buffer_v0);
      i = 0;
      while (i < nb) {
         oBuffer[i] = buffer_v0[i];
         i = i + 1;
      }
      v = v + 1;
   }
   // accumulate the others
   while (v < number_voices) {
      _ = poly:Poly.runVoice(v, nb, buffer_v0);
      i = 0;
      while (i < nb) {
	oBuffer[i] = oBuffer[i] + buffer_v0[i];
         i = i + 1;
      }
      v = v + 1;
   }
   // scale down
   i = 0;
   if (normalize) {
      while (i < nb) {
          oBuffer[i] = oBuffer[i] * voices_ratio;
          i = i + 1;
      }
   }
}

// several buffer
// FIXME: only set for 4 voices
and process_bufferTo_alt(nb: int, oBuffer: array(real, 256)) {
   // temporary buffer to hold each voice
   mem buffer_v0, buffer_v1, buffer_v2, buffer_v3;
   nb = clip(nb, 0, size(oBuffer));
   if (nb == 0) {
      nb = size(oBuffer);
   }
   _ = poly:Poly.runVoice(0, nb, buffer_v0);
   _ = poly:Poly.runVoice(1, nb, buffer_v1);
   _ = poly:Poly.runVoice(2, nb, buffer_v2);
   _ = poly:Poly.runVoice(3, nb, buffer_v3);
   val i = 0;
   if (normalize) {
      while (i < nb) {
         oBuffer[i] = (buffer_v0[i] + buffer_v1[i] + buffer_v2[i] + buffer_v3[i]) * voices_ratio;
         i = i + 1;
      }
   } else {
      while (i < nb) {
         oBuffer[i] = buffer_v0[i] + buffer_v1[i] + buffer_v2[i] + buffer_v3[i];
         i = i + 1;
      }
   }
}

// transmit noteOff to corresponding voice, update inner states active/inactive voice
and noteOff(note:int, channel:int) {
   // only 128 midi notes (and max voice)
   note = clip(note, 0, 127);
   // corresponding voice stored as voice+1
   val v = notes[note];
   // is this note really playing on a voice?
   if (v > 0 && v <= size(voices)) {
      // remove voice from active
      // channel 0, just because
      if (voicesactive:Notes.noteOff(v - 1, 0)) {
          // disable voice
          _ = poly:Poly.sendNoteOff(v - 1, note, channel);
          // update arrays
          notes[note] = 0;
	  voices[v-1] = 0;
	  // add voice to inactive (127 velocity, just because)
	  _ = voicesinactive:Notes.noteOn(v - 1, 127, 0);
      }
   }
}

// transmit noteOn to new voice (oldest inactive). If none, will turn off and steal oldest active. update inner states active/inactive voice
and noteOn(note:int, velocity:int, channel:int){
   // only 128 midi notes
   note = clip(note, 0, 127);
   // ignore note if already with a voice
   if (notes[note] <= 0) {
      // at least one free voice, take the oldest
      // todo: check both active and inactive status?
      val v = voicesinactive:Notes.firstNote();
      // no active voice, we will steal one
      if (v <= 0) {
         val active_v = voicesactive:Notes.firstNote();
	 // check we do indeed have one (the opposity would be a bug)
	 if (active_v > 0) {
	    // disable this voice (with arbitrary channel)
	    _ = noteOff(voices[active_v-1], 0);
	 }
      }
      // ne we should have at least one inactive voice
      v = voicesinactive:Notes.firstNote();
      if (v > 0) {
         // voice removed successfully from inactive ones and added to active ones (arbitrary channel 0 and velocity 127)
         if (voicesinactive:Notes.noteOff(v - 1, 0) && voicesactive:Notes.noteOn(v - 1, 127, 0)) {
	    // forward info
	    _ = poly:Poly.sendNoteOn(v - 1, note, velocity, channel);
            // update arrays
            notes[note] = v;
            voices[v-1] = note;
         }
      }
   }
}

// setter for the number of voices, from 0 (disable) to max size of inner buffer
and setNbVoices(nbvoices: int) {
   nbvoices = clip(nbvoices, 0, size(voices));
   // turn off voices that will be unused, highest voice first
   val i = voicesactive:Notes.nbNotes();
   while(i > nbvoices && i > 0) {
      // get note of current voice and turn it off (with arbitrary channel)
      _ = noteOff(voices[i-1], 0);
      // also remove from inactive
      _ = voicesinactive:Notes.noteOff(i - 1, 0);
      i = i - 1;
   }
   // turn on inactive voice, lowest first
   i = voicesinactive:Notes.nbNotes();
   while(i < nbvoices) {
      _ = voicesinactive:Notes.noteOn(i, 127, 0);
      i = i + 1;
   }


   number_voices = nbvoices;
   voices_ratio  = 1.0/real(number_voices);
}

// normalize: output maxed to -1 / 1 no matter the number of voices
and setNormalize(flag: bool) {
   normalize = flag;
}

// change sampling rate for current synth
and setSamplerate(newFs:real) {
   mem fs;
   if (newFs > 0.0) {
      fs = newFs;
   }
   _ = poly:Poly.setSamplerate(fs);
}

/* getter/setter passed down to synth, if supported */

// Sampler.setLoop()
and synthSetLoop(flag: bool) {
  _ =  poly:Poly.synthSetLoop(flag);
}

// Sampler.setLoopStart()
and synthSetLoopStart(value: int) {
  _ =  poly:Poly.synthSetLoopStart(value);
}

// Sampler.setLoopEnd()
and synthSetLoopEnd(value: int) {
  _ =  poly:Poly.synthSetLoopEnd(value);
}

// Sampler.getSampleSize()
and synthGetSize(): int {
  return poly:Poly.synthGetSize();
}

/* end parameters for synths */
 
and default() @[init] {
   _ = poly:Poly.default();

   buffer_v0 = Util.buffer();
   buffer_v1 = Util.buffer();
   buffer_v2 = Util.buffer();
   buffer_v3 = Util.buffer();

   mem voices: array(int, 4);
   number_voices = if number_voices == 0 then size(voices) else number_voices;
    // which notes are active, if so to which voice? (to select voice and prune duplicated note on/off). Stores voice number + 1
   _ = setNbVoices(number_voices);
   mem notes: array(int, 128);

   // monophonic algo used to keep track of active voices...
   _ = voicesactive:Notes.default();
   _ = voicesactive:Notes.setPoly(false);
   // and same for disabled voices
   _ = voicesinactive:Notes.default();
   _ = voicesinactive:Notes.setPoly(false);

   _ = setNormalize(true);
   _ = setSamplerate(44.1);
}
