
// reading samples

// TODO: (optional) loop points, kill on noteOff

external ocarina(channel:int, index:int) : real @[wave(channels=1, file="ocarina.wav")];

// return value for current wavetable (first channel hard-coded), between [0..sample size[
fun getSample(index: int) {
  return ocarina(0, index);
}

and process() {
  // absolutely needs init to set that
  mem size: int;
  // current position in sample and fractional leftovers to overcome limitation of fixed point
  mem pos: int;
  mem posFract: real;
  // how much we jump each step
  mem step: real;
  //  current gate
  mem gate: bool;
  // at the moment 0: not playing, 1: playing
  mem state: int;

  // advance time, keep range in check here to maximize precision
  posFract = posFract + step;
  if (posFract >= 1.0) {
    pos = pos + int(floor(posFract));
    posFract = posFract - floor(posFract);
    // will stop and reset note once reach the end
    if (pos > size) {
      state = 0;
      pos = 0;
      posFract = 0.0;
    }
  }

  val value = 0.0;
  if (state == 1) {
    value = getSample(pos);
  }
  return value;
}


and process_bufferTo(nb: int, oBuffer: array(real, 256)) {
  nb = clip(nb, 0, size(oBuffer));
  if (nb == 0) {
     nb = size(oBuffer);
  }

  val i = 0;
  while (i < nb) {


    // advance time, keep range in check here to maximize precision
    posFract = posFract + step;
    if (posFract >= 1.0) {
      pos = pos + int(floor(posFract));
      posFract = posFract - floor(posFract);
      // will stop and reset note once reach the end
      if (pos > size) {
        state = 0;
        pos = 0;
        posFract = 0.0;
      }
    }
    
    if (state == 1) {
      oBuffer[i] = getSample(pos);
    }
    else {
      oBuffer[i] = 0.0;
    }
    i = i + 1;
   }
}

// retrocompatibility: using inner buffer
and process_buffer(nb: int) {
  mem buffer_o;
  _ = process_bufferTo(nb, buffer_o);
}


// called internally when Samplerate or frequency is altered
and updateStep() {
  // current note frequency
  mem freq: real;
  // base for computing step
  mem stepRatio: real;
  // both for efficiency and because we don't want any result to be outside [1/32767 .. 32767] to avoid fixed float limits we compute step in two... steps
  step = freq*stepRatio;
}

// seter for parameters. expect values of desired frequency and current sampling rate in kHz to avoid fixed float limits ([1/32767 ..32767]... probably)
and setSamplerate(newFs:real) {
  // sample rate of the recording
  mem sampleFs;
  // note of the sample
  mem sampleFreq;
  // audio sampling rate
  mem fs: real;
   if (newFs > 0.0) {
      fs = newFs;
      // update ratio when we update sampling rate
      stepRatio = fs/sampleFs/sampleFreq;
   }
   _ = updateStep();
}
// frequency of the note to be played
and setFrequency(newFreq:real) {
   freq = newFreq;
   _ = updateStep();
}

// beginning of a note -- will effectively ignore duplicated noteOn for same note
// we don't check velocity, yet
and noteOn(note:int, velocity:int, channel:int){
   // only 128 midi notes
   note = clip(note, 0, 127);
   // only acts if action taken into account
   if (playingnotes:Notes.noteOn(note, velocity, channel)) {
       // set frequency... should we reset phase somehow? artifacts upon first tests
       _ = setFrequency(Util.noteToFrequency(note));
       // gate and start playing note
       gate = true;
       pos = 0;
       posFract = 0.0;
       state = 1;
   }
}

// set polpyphonic (true flag) or monophonic (false flag)
// monophonic: will get back to former notes, if any, upon note off
// polyphonic: does try to get back to held notes frequencies
and setPoly(flag: bool) {
   _ = playingnotes:Notes.setPoly(flag);
}

// note off whatever the channel, back to frequency of last still active note if any
and noteOff(note:int, channel:int) {
   // only 128 midi notes
   note = clip(note, 0, 127);
   // only acts if action taken into account
   if (playingnotes:Notes.noteOff(note, channel)) {
      // still gate on-going if there are note held, and switch to last
      if (playingnotes:Notes.nbNotes() > 0){
         val last_played = playingnotes:Notes.lastNote();
	 // check we do have a note -- and that it's in range
         if (last_played > 0 && last_played <= 128) {
	   // FIXME: retrigger note as well (set pos 0)??
            _ = setFrequency(Util.noteToFrequency(last_played - 1));
         }
      } else {
         gate = false;
      }
   }
}

and default() @[init] {
  // defaults for current sample
  sampleFs = 44.100;
  // here C4 (still in kHz)
  sampleFreq = 0.2616;
  // will copy a new array
  mem buffer_o = Util.buffer();
  size = ocarina_samples();
  _ = setSamplerate(44.1);
  // default frequency (in kHz)
  _ = setFrequency(0.440);

  // monophonic by default
  _ = playingnotes:Notes.default();
  _ = setPoly(false);
}
