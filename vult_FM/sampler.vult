
// reading samples. Using linear interpolation to adjust pitch.
// Option to loop a section upon a held note WARNING: end loop must be at least two samples after start loop, and longer than max used step!

// TODO: (optional) loop points, kill on noteOff

external ocarina(channel:int, index:int) : real @[wave(channels=1, file="ocarina.wav")];

// return value for current wavetable (first channel hard-coded), between [0..sample size[
fun getSample(index: int) {
  return ocarina(0, index);
}

and process() {
  // absolutely needs init to set that
  mem size: int;
  // if we should loop on note held, if so start and end position in samples.
  mem loopy: bool;
  mem loopS: int;
  mem loopE: int;
  // using integer "base position" float position to overcome limitation of fixed point
  mem posBase: int;
  mem pos: real;
  // how much we jump each step
  mem step: real;
  // at the moment 0: not playing, 1: playing (eventually looping), 2: stopping
  mem state: int;

  val value = 0.0;

  if (state > 0) {
    // advance time, keep range in check here to maximize precision
    pos = pos + step;
    while (pos >= 1024.0) {
      posBase = posBase + 1024;
      pos = pos - 1024.0;
    }
    val idx = posBase + int(pos);

    // will stop and reset note once reach the end
    if (idx > size) {
      state = 0;
      posBase = 0;
      pos = 0.0;
    }
    else {
      if (state == 1 && loopy && idx >= loopE) {
        // reset index and position to left
        idx = loopS + (idx - loopE);
        posBase = idx;
        pos = pos - floor(pos);
      }
      // linear interpolation betweet samples
      value = getSample(idx) + (pos - floor(pos)) * (getSample(idx+1) - getSample(idx));
    }
  }

  return value;
}


and process_bufferTo(nb: int, oBuffer: array(real, 256)) {
  nb = clip(nb, 0, size(oBuffer));
  if (nb == 0) {
     nb = size(oBuffer);
  }

  val idx = 0;
  val i = 0;
  while (i < nb) {
    if (state > 0) {
      // advance time, keep range in check here to maximize precision
      pos = pos + step;
      while (pos >= 1024.0) {
        posBase = posBase + 1024;
        pos = pos - 1024.0;
      }
      idx = posBase + int(pos);
  
      // will stop and reset note once reach the end
      if (idx > size) {
        state = 0;
        posBase = 0;
        pos = 0.0;
        oBuffer[i] = 0.0;
      }
      else {
        if (state == 1 && loopy && idx >= loopE) {
          // reset index and position to left
          idx = loopS + (idx - loopE);
          posBase = idx;
          pos = pos - floor(pos);
        }
        // linear interpolation betweet samples
        oBuffer[i] = getSample(idx) + (pos - floor(pos)) * (getSample(idx+1) - getSample(idx));
      }
    } else {
      oBuffer[i] = 0.0;
    }

    i = i + 1;
  }
}

// retrocompatibility: using inner buffer
and process_buffer(nb: int) {
  mem buffer_o;
  _ = process_bufferTo(nb, buffer_o);
}


// called internally when Samplerate or note is altered
and updateStep() {
  // base for computing step
  mem noteRatio: real;
  mem fsRatio: real;
  // both for efficiency and because we don't want any result to be outside [1/32767 .. 32767] to avoid fixed float limits we compute step in two... steps
  step = noteRatio*fsRatio;
}

// seter for parameters. expect values of desired frequency and current sampling rate in kHz to avoid fixed float limits ([1/32767 ..32767]... probably)
and setSamplerate(newFs:real) {
  // sample rate of the recording
  mem sampleFs;
  // note of the sample
  mem sampleNote;
  // audio sampling rate
  mem fs: real;
   if (newFs > 0.0) {
      fs = newFs;
      // update ratio when we update sampling rate
      fsRatio = sampleFs/fs;
   }
   _ = updateStep();
}


// true for note to loop upon being held, false for one-shot
and setLoop(loop: bool) {
  loopy = loop;
}
// loop point for start (0 to sample size)
and setLoopStart(newLoopS: int) {
  loopS = clip(newLoopS, 0, size);
}
// loop point for start (0 to sample size)
and setLoopEnd(newLoopE: int) {
  loopE = clip(newLoopE, 0, size);
}

// number of samples (note: valid once init)
and getSampleSize() {
  return size;
}

// note to be played. Here only handle equal temperament
and setNote(note: int) {
  // use ratio of note rather than freq to be more precise, +1 octave (12 semitones) doubles speed, -1 octave halves it
  val log_two = log10(2.0)/log10(exp(1.0)); // so that vultc replace with result of log(2)
  val semitones = real(note-sampleNote)/12.0;
  noteRatio = exp(log_two * semitones);
  _ = updateStep();
}

// beginning of a note -- will effectively ignore duplicated noteOn for same note
// we don't check velocity, yet
and noteOn(note:int, velocity:int, channel:int){
   // only 128 midi notes
   note = clip(note, 0, 127);
   // only acts if action taken into account
   if (playingnotes:Notes.noteOn(note, velocity, channel)) {
       // set frequency... should we reset phase somehow? artifacts upon first tests
       _ = setNote(note);
       // start playing note
       posBase = 0;
       pos = 0.0;
       state = 1;
   }
}

// set polpyphonic (true flag) or monophonic (false flag)
// monophonic: will get back to former notes, if any, upon note off
// polyphonic: does try to get back to held notes frequencies
and setPoly(flag: bool) {
   _ = playingnotes:Notes.setPoly(flag);
}

// note off whatever the channel, back to frequency of last still active note if any
and noteOff(note:int, channel:int) {
   // only 128 midi notes
   note = clip(note, 0, 127);
   // only acts if action taken into account
   if (playingnotes:Notes.noteOff(note, channel)) {
      // still gate on-going if there are note held, and switch to last
      if (playingnotes:Notes.nbNotes() > 0){
         val last_played = playingnotes:Notes.lastNote();
	 // check we do have a note -- and that it's in range
         if (last_played > 0 && last_played <= 128) {
	   // FIXME: retrigger note as well (set pos 0)??
	   _ = setNote(last_played - 1);
         }
      } else {
 	 // letting note go
	 state = 2;
      }
   }
}

and default() @[init] {
  // defaults for current sample
  sampleFs = 30.0;
  // here C4
  sampleNote = 60;
  // looping sample
  loopy = true;
  loopS = 5073;
  loopE = 5992;
  // will copy a new array
  mem buffer_o = Util.buffer();
  size = ocarina_samples();
  _ = setSamplerate(44.1);
  // default frequency (in kHz)
  _ = setNote(69);

  // monophonic by default
  _ = playingnotes:Notes.default();
  _ = setPoly(false);
}
