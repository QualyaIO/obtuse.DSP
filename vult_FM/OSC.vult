
// oscillator, using waveables

// note that wavetable should be big enough to avoid fixed float limits upon later computations (let say at least 100)

// 0 -> sine
external sin_wave(channel:int, index:int) : real @[wave(channels=1, file="sinus_8k.wav")];


// return value for current wavetable (first channel hard-coded), between [0..sample size[
fun getSample(index: int) {
    // index of wavetable
    mem wavetable;
    // modulo will be taken care of by the generated code 
    val sample = 0.0;
    if (wavetable == 0) {
       sample = sin_wave(0, index);
    }
    return sample;
}

// --> main function actually here, call default() first <--
// buffered version, specify number of elements of the buffer to proceed (will be caped to acual max). 0: all elements
// update the buffer, to be fetch afterward, returns last sample
// phaseÂ bases: specify the point of reference of the phase for each sample
// FIXME: not check for phase_bases size, no option to by-pass
and process_buffer(nb: int, phase_bases: array(real, 256)) {
   mem buffer;
   nb = clip(nb, 0, size(buffer));
   if (nb == 0) {
      nb = size(buffer);
   }
   
   // audio sampling rate
   mem fs: real;
   // sinus frequency
   mem freq: real;
   // starting point for phase, [0..8k[ in the wavetable
   mem phase_base: real;
   // current phase
   mem phase: real;
   // going that much through wavetable at each call
   mem step: real;

   // absolutely needs init to set that, converted to real to speedup
   mem rsize: real;

   val i = 0;
   val v = 0.0;
   while (i < nb) {
      // advance time, keep range in check here to maximize precision
      phase = phase + step;
      // slightly more efficient than the more robust modulo
      if (phase > rsize) {
         phase = phase - rsize;
      }
      // loop in sample
      //v = getSample(int(phase_base + phase));
      v = getSample(int(phase_bases[i] + phase));
      buffer[i] = v;
      i = i + 1;
   }

   return v;
}

// non-buffered version... FIXME: not supported anymore
and process() {
   return 0.0;
}

// called internally when Samplerate or frequency is altered
and updateStep() {
    // base for computing step
    mem stepRatio;
    // both for efficiency and because we don't want any result to be outside [1/32767 .. 32767] to avoid fixed float limits we compute step in two... steps
    step = stepRatio*freq;
}
and getBuffer() {
   return buffer;
}
// seter for parameters. expect values of desired frequency and current sampling rate in kHz to avoid fixed float limits ([1/32767 ..32767]... probably)
and setSamplerate(newFs:real) {
   if (newFs > 0.0) {
      fs = newFs;
      // update ratio when we update sampling rate
      stepRatio = rsize / fs;
   }
   _ = updateStep();
}
and setFrequency(newFreq:real) {
   freq = newFreq;
   _ = updateStep();
}
// setting *base* phase [0..size[ -- we won't check here, beware!
and setPhase(newPhase: real) {
   phase_base = newPhase;
}
// reset both base phase and current phase, typically used upon new note
and resetPhase() {
   phase = 0.0;
   phase_base = 0.0;
}
// see options at the top of the file
// reset to 0 if invalid wavetable is selected
and setWavetable(index: int) {
    if (wavetable == 0) {
       rsize = real(sin_wave_samples());
    }
    // sefault to sine
    else {
       setWavetable(0);
    }
}
// size of selected wavetable (int)
and getSize() : int {
    return int(rsize);
}
// copy current buffer to another one up to desired number (0 for max)
// too bad we have to hard-code size here
and copyTo(oBuffer:array(real, 256), nb: int){
   // ensure we won't overflow
   val min_size = size(oBuffer);
   if (size(buffer) < min_size) {
      min_size = size(buffer);
   }
   nb = clip(nb, 0, min_size);
   if (nb == 0) {
      nb = min_size;
   }
   val i = 0;
   while (i < nb) {
      oBuffer[i] = buffer[i];
      i = i + 1;
   }
}
and default() @[init] {
   // will copy a new array
   buffer = Util.buffer();
   // default sampling rate (in kHz)
   _ = setSamplerate(44.1);
   // default sine
   _ = setWavetable(0);
   // default frequency (in kHz)
   _ = setFrequency(0.440);
}