
// oscillator, using waveables
// TODO: dublicate code here as well between process and process_buffer (and "simple" version! for sake of efficiency)

// note that wavetable should be big enough to avoid fixed float limits upon later computations (let say at least 100). Too small and audio artifacts will occur (e.g. sine 2048 not so great) too big and CPU will take a hit. 4096 hears a good tradeoff

// 0 -> sine,
external sin_wave(channel:int, index:int) : real @[wave(channels=1, file="sinus_4096.wav")];

// return value for current wavetable (first channel hard-coded), between [0..sample size[
fun getSample(index: int) {
    // index of wavetable
    mem wavetable;
    // modulo will be taken care of by the generated code 
    val sample = 0.0;
    if (wavetable == 0) {
       sample = sin_wave(0, index);
    }
    return sample;
}


// non-buffered version
and process() {
   // audio sampling rate
   mem fs: real;
   // sinus frequency
   mem freq: real;
   // starting point for phase, [0..8k[ in the wavetable
   mem phase_base: real;
   // current phase
   mem phase: real;
   // going that much through wavetable at each call
   mem step: real;
   // absolutely needs init to set that, converted to real to speedup
   mem rsize: real;

   // advance time, keep range in check here to maximize precision
   phase = phase + step;
   while (phase > rsize) {
      phase = phase - rsize;
   }
   // loop in sample
   return getSample(int(phase_base + phase));
}


// --> main function actually here, call default() first <--
// buffered version, specify number of elements of the buffer to proceed (will be caped to acual max). 0: all elements
// update the buffer, to be fetch afterward, returns last sample
// env: envelope to apply (0..1)
// phaseÂ shift: specify how to shift the base phase (-1 to 1, 0 center of phase) -- FIXME so that 0 does not change anything?
// phase_shift_level: by how much we apply phase shift (0..1)
// oBuffer: output buffer to copy data to
// FIXME: not check for phase_bases size, no option to by-pass
and process_bufferTo(nb: int, env: array(real, 256), phase_shift: array(real, 256), phase_shift_level: real, oBuffer: array(real, 256)) {
   nb = clip(nb, 0, size(oBuffer));
   if (nb == 0) {
      nb = size(oBuffer);
   }
   
   // base for phase shift
   val half_phase = rsize / 2.0;
   val phase_range = half_phase * phase_shift_level;

   val i = 0;
   while (i < nb) {
      // advance time, keep range in check here to maximize precision
      phase = phase + step;
      // slightly more efficient than the more robust modulo
      while (phase > rsize) {
         phase = phase - rsize;
      }
      // loop in sample
      oBuffer[i]  = getSample(int(half_phase + phase_range * phase_shift[i]  + phase)) * env[i];
      i = i + 1;
   }
}
// retrocompatibility: using inner buffer
and process_buffer(nb: int, env: array(real, 256), phase_shift: array(real, 256), phase_shift_level: real) {
   mem buffer_o;
   _ = process_bufferTo(nb, env, phase_shift, phase_shift_level, buffer_o);
}

// without phase this one
and process_bufferTo_simple(nb: int, env: array(real, 256), oBuffer: array(real, 256)) {
   nb = clip(nb, 0, size(oBuffer));
   if (nb == 0) {
      nb = size(oBuffer);
   }
   
   val i = 0;
   while (i < nb) {
      // advance time, keep range in check here to maximize precision
      phase = phase + step;
      // slightly more efficient than the more robust modulo
      while (phase > rsize) {
         phase = phase - rsize;
      }
      // loop in sample
      //v = getSample(int(phase_base + phase));
      oBuffer[i]  = getSample(int(phase_base + phase)) * env[i];
      i = i + 1;
   }
}

and process_buffer_simple(nb: int, env: array(real, 256)) {
   _ = process_bufferTo_simple(nb, env, buffer_o);
}

// without envelop nor phase this one
and process_bufferTo_simplest(nb: int, oBuffer: array(real, 256)) {
   nb = clip(nb, 0, size(oBuffer));
   if (nb == 0) {
      nb = size(oBuffer);
   }
   
   val i = 0;
   while (i < nb) {
      // advance time, keep range in check here to maximize precision
      phase = phase + step;
      // slightly more efficient than the more robust modulo
      while (phase > rsize) {
         phase = phase - rsize;
      }
      // loop in sample
      //v = getSample(int(phase_base + phase));
      oBuffer[i]  = getSample(int(phase_base + phase));
      i = i + 1;
   }
}


and process_buffer_simplest(nb: int) {
   _ = process_bufferTo_simplest(nb, buffer_o);
}

// called internally when Samplerate or frequency is altered
and updateStep() {
    // base for computing step
    mem stepRatio;
    // both for efficiency and because we don't want any result to be outside [1/32767 .. 32767] to avoid fixed float limits we compute step in two... steps
    step = stepRatio*freq;
}
and getBuffer() {
   return buffer_o;
}
// seter for parameters. expect values of desired frequency and current sampling rate in kHz to avoid fixed float limits ([1/32767 ..32767]... probably)
and setSamplerate(newFs:real) {
   if (newFs > 0.0) {
      fs = newFs;
      // update ratio when we update sampling rate
      stepRatio = rsize / fs;
   }
   _ = updateStep();
}
and setFrequency(newFreq:real) {
   freq = newFreq;
   _ = updateStep();
}
// setting *base* phase [0..size[ -- we won't check here, beware!
and setPhase(newPhase: real) {
   phase_base = newPhase;
}
// reset both base phase and current phase, typically used upon new note
and resetPhase() {
   phase = 0.0;
   phase_base = 0.0;
}
// see options at the top of the file
// reset to 0 if invalid wavetable is selected
and setWavetable(index: int) {
    if (wavetable == 0) {
       rsize = real(sin_wave_samples());
    }
    // sefault to sine
    else {
       setWavetable(0);
    }
}
// size of selected wavetable (int)
and getSize() : int {
    return int(rsize);
}
// copy current buffer to another one up to desired number (0 for max)
// too bad we have to hard-code size here
and copyTo(oBuffer:array(real, 256), nb: int){
   // ensure we won't overflow
   val min_size = size(oBuffer);
   if (size(buffer_o) < min_size) {
      min_size = size(buffer_o);
   }
   nb = clip(nb, 0, min_size);
   if (nb == 0) {
      nb = min_size;
   }
   val i = 0;
   while (i < nb) {
      oBuffer[i] = buffer_o[i];
      i = i + 1;
   }
}
and default() @[init] {
   // will copy a new array
   mem buffer_o = Util.buffer();
   // default sampling rate (in kHz)
   _ = setSamplerate(44.1);
   // default sine
   _ = setWavetable(0);
   // default frequency (in kHz)
   _ = setFrequency(0.440);
}
