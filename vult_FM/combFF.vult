
// Comb filter, i.e. delay with decay
// Here more specifically implements a feedforward comb filter
// Output will be kept to -1..1 range

fun process(sample: real) {
    // internal buffer, for delay
    mem buffer;
    // current position inside it
    mem pos;
    // how far in the buffer in samples we go
    mem delay;
    // attenuation for each pass
    mem decay;
    // multiplicator to keep output amplitude in check (direclty related to decay, computed once)
    mem scale;

    // buffer holds delayed signal 
    val decayed = buffer[pos] * decay;
    buffer[pos] = sample;

    // advance and loop on actual delay size    
    pos = pos + 1;
    pos = pos % delay;

    return (sample + decayed) * scale;
}

and process_bufferTo(nb: int, input: array(real, 256), oBuffer: array(real, 256)) {
    nb = clip(nb, 0, size(oBuffer));
    if (nb == 0) {
       nb = size(oBuffer);
    }

    // delayed sample with decay
    val decayed;

    val i = 0;
    while (i < nb) {
       decayed = buffer[pos] * decay;
       buffer[pos] = input[i];
       oBuffer[i] = (buffer[pos] + decayed) * scale;
       pos = pos + 1;
       pos = pos % delay;
       i = i + 1;
    }
}
and process_buffer(nb: int, input: array(real, 256)) {
    mem buffer_o;
    _ = process_bufferTo(nb, input, buffer_o);
}
// copy current buffer to another one up to desired number (0 for max)
// too bad we have to hard-code size here
and getBuffer() {
   return buffer_o;
}
and copyTo(oBuffer:array(real, 256), nb: int){
   // ensure we won't overflow
   val min_size = size(oBuffer);
   if (size(buffer_o) < min_size) {
      min_size = size(buffer_o);
   }
   nb = clip(nb, 0, min_size);
   if (nb == 0) {
      nb = min_size;
   }
   val i = 0;
   while (i < nb) {
      oBuffer[i] = buffer_o[i];
      i = i + 1;
   }
}

// setter for decay, here on
and setDecay(newDecay: real) {
  decay = clip(newDecay, 0.0, 1.0);
  scale = 1.0 / (1.0 + decay);
}

// get max delay in sampless
and getMaxDelay() : int {
  return size(buffer);
}

// get max delay in ms
and getMaxDelayms() : real {
  mem fs;
  if (fs <= 0.0) {
     return 0.0;
  }
  // we have frequency in kHz, directly get ms
  return real(size(buffer)) / fs;
}

// change delay (in samples). Will be caped at max buffersize -- check that with getMaxDelay()
// Warning: does *not* reset buffer upon change
// Note: with fixed float cannot above 32767ms (just in case it would make sense to have a 30s buffer on a platform which needs fixed float).,
and setDelay(newDelay: int) {
   mem fs;
   delay = clip(newDelay, 0, getMaxDelay());
   // reset position in buffer
   pos = 0;
}

// change delay (in miliseconds). Will be caped at max buffersize -- check that with getMaxDelayms()
// Warning: does *not* reset buffer upon change
// Note: with fixed float cannot ask above 32767ms (just in case it would make sense to have a 30s buffer on a platform which needs fixed float). Prefer setDelay (in samples) to go beyond
and setDelayms(delayms: real) {
   mem fs;
   setDelay(int(fs * delayms));
}

// seter for parameters. expect values of desired frequency and current sampling rate in kHz to avoid fixed float limits ([1/32767 ..32767]... probably)
// WARNING: will *not* update delay (as it could have been passed with samples directly or by ms), to be called first, and should manually ask to update if delay in ms is important
and setSamplerate(newFs:real) {
   if (newFs > 0.0) {
      fs = newFs;
   }
}

and default() @[init] {
   buffer = Util.buffer_large();
   // output values (with delay), will copy a new array
   buffer_o = Util.buffer();
   _ = setSamplerate(44.100);
   _ = setDelayms(50.0);
   _ = setDecay(0.5);
}
