
// midi note to frequency, 440hz base, equal temperament, as per MIDI standard. Return number in kHz to migitate issues with fixed float
// TODO: use a table instead?
fun noteToFrequency(note: int) {
    //0.440 x 2^((note - 69)/12.)
    return 0.008175798915643707 * exp(0.057762265046662105 * real(note)); 
}

// from vult examples
fun edge(x:bool) : bool {
   mem pre;
   val ret = x && not(pre);
   pre = x;
   return ret;
}

fun cubic_clipper(x) {
   if(x <= -2.0/3.0)
      return -2.0/3.0;
   else if(x >= 2.0/3.0)
      return 2.0/3.0;
   else
      return x - (x * x * x) / 3.0;
}

fun change(x:real):bool {
    mem pre_x;
    val v:bool = pre_x <> x;
    pre_x = x;
    return v;
}

// allocate an audio buffer
// size tuned for current use, default non-blocking I2S buffer
fun buffer() {
  val buff : array(real, 256);
  return buff;
}

// allocate an audio buffer, this one for things like effects. Be wary of memory consumption -- and most probably avoid to put in PROGMEM in MCU
// Note: used in reverb, which needs at least 1123 samples for default values
fun buffer_large() {
  val buff : array(real, 2048);
  return buff;
}

// smooth transition to a value
// coeff: should be ]0..1] from slow to instantaneous
fun smooth(input, coeff:real){
   mem x;
   x = x+(input-x)*coeff;
   return x;
}
