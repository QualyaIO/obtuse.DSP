// linear ADSR envelope
// Magic numbers:
// 1024.0 : improves numeric precision in fixed-point


fun process(bgate:bool) {
   // uber state machine
   mem state: int;
   // target values
   mem s: real;
   mem a_step: real;
   mem d_step: real;
   mem r_step: real;
   // current output and then current step toward target
   mem out: real;
   mem step: real;
   // current target
   mem target: real;
   // target for attack, just in case it could be changed at some point
   mem  a_target;
   // internal output and target x 1000 to deal with fixed point precision (also corresponds to the fact that samplerate is in kHz)
   val scale = 1000.0;
   // ...faster to multiply by 1/1000...
   val scale_i = 0.001;

   // new gate, goto attack
   if(Util.edge(bgate)) {
      state = 1;
      target = a_target * scale;
      step = a_step;
   }

   // idle, really nothing to do 
   if(state == 0) {
     out = 0.0;
   }
   else {
     out = out + step; 
   }
   // attack
   if(state == 1) {
      // peaked, going to decay
      if(out >=  target) {
         step = d_step;
         out = target;
      	 target = s * scale;
      	 state = 2;
      }
      // gate off, to go release
      if (not(bgate)) {
         step = r_step;
         target = 0.0;
         state = 4;
      }
   }
   // decay
   if (state == 2) {
      // gate off, to go release
      if (not(bgate)) {
         step = r_step;
         target = 0.0;
         state = 4;
      }
      // target reached, go to sustain
      if (out <= target) {
         out = target;
         step = 0.0;
	 state = 3;
      }

   }
   // sustain
   if (state == 3) {
      // just waiting for the gate to end, go to release
      if (not(bgate)) {
         step = r_step;
         target = 0.0;
         state = 4;
      }
   }

    // release
   if(state == 4) {
      // back to idle
      if (out <= 0.0) {
         out = 0.0;
	 state = 0;
         step = 0.0;
         target = 0.0;
      }
   }

   return clip(out * scale_i, 0.0, 1.0);
}


// one gate for the whole buffer at the moment
// return
and process_bufferTo(bgate:bool, nb:int, oBuffer: array(real, 256)): bool {
   nb = clip(nb, 0, size(oBuffer));
   if (nb == 0) {
      nb = size(oBuffer);
   }

   // internal output and target x 1000 to deal with fixed point precision (also corresponds to the fact that samplerate is in kHz)
   val scale = 1000.0;
   // ...faster to multiply by 1/1000...
   val scale_i = 0.001;
   val idle = true;

   val i = 0;
   val v = 0.0;
   while (i < nb) {

      // new gate, goto attack
      if(Util.edge(bgate)) {
         state = 1;
         target = a_target * scale;
         step = a_step;
      }

      // idle, really nothing to do 
      if(state == 0) {
        out = 0.0;
      }
      else {
        idle = false;
        out = out + step; 

        // attack
        if(state == 1) {
           // peaked, going to decay
           if(out >=  target) {
              step = d_step;
              out = target;
              target = s * scale;
              state = 2;
           }
           // gate off, to go release
           if (not(bgate)) {
              step = r_step;
              target = 0.0;
              state = 4;
           }
        }
        // decay
        if (state == 2) {
           // gate off, to go release
           if (not(bgate)) {
              step = r_step;
              target = 0.0;
              state = 4;
           }
           // target reached, go to sustain
           if (out <= target) {
              out = target;
              step = 0.0;
	      state = 3;
           }
  
        }
        // sustain
        if (state == 3) {
           // just waiting for the gate to end, go to release
           if (not(bgate)) {
              step = r_step;
              target = 0.0;
              state = 4;
           }
        }
   
       // release
        if(state == 4) {
         // back to idle
         if (out <= 0.0) {
            out = 0.0;
   	 state = 0;
            step = 0.0;
            target = 0.0;
         }
        }
      }
   
      oBuffer[i] = clip(out * scale_i, 0.0, 1.0);
      i = i + 1;
   }
   return idle;
}

and process_buffer(bgate:bool, nb:int) {
   mem buffer_o;
   return process_bufferTo(bgate, nb, buffer_o);
}

// once sample rate change, we need to adapt 
and updateSteps() {
   mem a, d, r, fs;
   // to avoid division by 0 and cliks, smooth at least a tiny bit. Note that sample rate of envelope should match that
   val min_t = 0.01;
   // to stay within fixed point limit we don't want the left part too big (target value as precise as the scale let it be, around 0.01 threshold), and the right part too big (too much time) -- rember limit [1/32767 .. 32767]
   // Note: because target will be scaled to 1000, compensate for sample rate in kHz
   a_step = a_target / (fs * (a + min_t));
   // decay will go from 1 to sustain
   d_step = (s - a_target) / (fs * (d + min_t));
   // release from sustain to nothingness
   r_step = (- s) / (fs * (r + min_t));
}

// current sampling rate in kHz
// note: sample rate of ADSR can be different from audio to save on computations, but beware of artifacts (try at least 10kHz)
and setSamplerate(newFs:real) {
   if (newFs > 0.0) {
      fs = newFs;
   }
   _ = updateSteps();
}


// attack: time (s) to peak output at 1.0 -- limit to 60s (for fixed point sake)
// decay: time (s) to get to sustain level -- limit to 60s
// sustain: level when note is held (0..1)
// release: time (s) to get from sustain level to 0 -- limit to 60s
// Note: will set internally minimal value of 0.01, suitable for at least 10kHz
and config(newA, newD, newS, newR) {
   val max_t = 60.0;
   // sanity check
   a =  clip(newA, 0.0, max_t);
   d =  clip(newD, 0.0, max_t);
   s =  clip(newS, 0.0, 1.0);
   r =  clip(newR, 0.0, max_t);
   // so heavy computations
   _ = updateSteps();
}

// copy current buffer to another one up to desired number (0 for max)
// too bad we have to hard-code size here
and copyTo(oBuffer:array(real, 256), nb: int){
   // ensure we won't overflow
   val min_size = size(oBuffer);
   if (size(buffer_o) < min_size) {
      min_size = size(buffer_o);
   }
   nb = clip(nb, 0, min_size);
   if (nb == 0) {
      nb = min_size;
   }
   val i = 0;
   while (i < nb) {
      oBuffer[i] = buffer_o[i];
      i = i + 1;
   }
}

and default() @[init] {
   // will copy new arrays
   buffer_o = Util.buffer();
   // Note: if fore some reason becomes < s, adapt decay to check if we reach sustain "from below" in process()
   mem a_target = 1.0;
   _ = setSamplerate(44.1);
   //_ = config(1.0, 1.0, 0.8, 1.0);
   _ = config(0.0, 0.0, 0.5, 0.0);
}
