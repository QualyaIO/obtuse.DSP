// linear ADSR envelope
// Magic numbers:
// 1024.0 : improves numeric precision in fixed-point

// attack: time (s) to peak output at 1.0 -- limit to 60s (for fixed point sake)
// decay: time (s) to get to sustain level -- limit to 60s
// sustain: level when note is held (0..1)
// release: time (s) to get from sustain level to 0 -- limit to 60s
// max values for ADSR, used to clamp in config()
fun getMaxValues() {
   val max_t = 60.0;
   return (max_t, max_t, 1.0, max_t);
}

fun getMaxAttack() {
  val max_a, _, _, _ = getMaxValues();
  return max_a;
}

fun getMaxDecay() {
  val _, max_d, _, _ = getMaxValues();
  return max_d;
}

fun getMaxSustain() {
  val _, _, max_s, _ = getMaxValues();
  return max_s;
}

fun getMaxRelease() {
  val _, _, _, max_r = getMaxValues();
  return max_r;
}

fun getMinValues() {
   // 1ms minimum -- should be > 0 to avoid errors in updateSteps()
   val min_t = 0.001;
   return (min_t, min_t, 0.0, min_t);
}

fun getMinAttack() {
  val min_a, _, _, _ = getMinValues();
  return min_a;
}

fun getMinDecay() {
  val _, min_d, _, _ = getMinValues();
  return min_d;
}

fun getMinSustain() {
  val _, _, min_s, _ = getMinValues();
  return min_s;
}

fun getMinRelease() {
  val _, _, _, min_r = getMinValues();
  return min_r;
}


// return release step from "current value" to 0, e.g. when note released earlier
fun stepToRelease(curr_val: real) {
   // parameters
   mem a, d, r, fs;
   // to avoid division by 0 and cliks, smooth at least a tiny bit. Note that sample rate of envelope should match that
   return (-curr_val) / (fs * (clip(r, getMinRelease(), r)));
}

and process(bgate:bool) {
   // uber state machine
   mem state: int;
   // target values
   mem s: real;
   mem a_step: real;
   mem d_step: real;
   mem r_step: real;
   // current output and step toward target
   mem out: real;
   mem step: real;
   // current target
   mem target: real;
   // target for attack, just in case it could be changed at some point
   mem  a_target;
   // can force to retrigger from outside, e.g. several note on
   mem retrigger;
   // can apply a level to the envelop, current one and the one to target
   mem level: real;
   mem target_level: real;
   // step to apply between levels, ref and actual
   mem level_step_ref: real;
   mem level_step: real;
   // reduce cost of envelopes, only computes once in a while
   mem env_decimation_factor;
   // number of iteration of this loop, for decimation
   mem n;
   // internal output and target x 1000 to deal with fixed point precision (also corresponds to the fact that samplerate is in kHz)
   val scale = 1000.0;
   // ...faster to multiply by 1/1000...
   val scale_i = 0.001;
   
   n = n + 1;
   // stop right there if not time to update
   if (env_decimation_factor > 1 && n % env_decimation_factor <> 0) {
     return clip((out * scale_i)*level, 0.0, 1.0);
   }

   // new gate, goto attack
   if(Util.edge(bgate) || retrigger) {
      state = 1;
      target = a_target * scale;
      step = a_step;
      retrigger = false;
   }

   // smooth level change
   if (level <> target_level) {
     level = level + level_step;
     // reached target
     if (
	 (level_step > 0.0 && level > target_level) ||
	 (level_step < 0.0 && level < target_level)
	 ) {
       level = target_level;
     }
   }
     
   // idle, really nothing to do 
   if(state == 0) {
     out = 0.0;
   }
   else {
     out = out + step; 
   }
   // attack
   if(state == 1) {
      // peaked, going to decay
      if(out >=  target) {
         step = d_step;
         out = target;
      	 target = s * scale;
      	 state = 2;
      }
      // gate off, to go release
      if (not(bgate)) {
         step = stepToRelease(out*scale_i);
         target = 0.0;
         state = 4;
      }
   }
   // decay
   if (state == 2) {
      // gate off, to go release
      if (not(bgate)) {
         step = stepToRelease(out*scale_i);
         target = 0.0;
         state = 4;
      }
      // target reached, go to sustain
      if (out <= target) {
         out = target;
         step = 0.0;
	 state = 3;
      }

   }
   // sustain
   if (state == 3) {
      // just waiting for the gate to end, go to release
      if (not(bgate)) {
         step = r_step;
         target = 0.0;
         state = 4;
      }
   }

    // release
   if(state == 4) {
      // back to idle
      if (out <= 0.0) {
         out = 0.0;
	 state = 0;
         step = 0.0;
         target = 0.0;
      }
   }

   return clip((out * scale_i) * level, 0.0, 1.0);
}


// one gate for the whole buffer at the moment
// return idle state: true if envelope finished
and process_bufferTo(bgate:bool, nb:int, oBuffer): bool {
  nb = clip(nb, 0, size(oBuffer));
  if (nb == 0) {
    nb = size(oBuffer);
  }
  
  // internal output and target x 1000 to deal with fixed point precision (also corresponds to the fact that samplerate is in kHz)
  val scale = 1000.0;
  // ...faster to multiply by 1/1000...
  val scale_i = 0.001;
  val idle = true;
  
  val i = 0;
  
  // new gate, goto attack
  // NOTE: compared to process() we check gate no matter decimation
  if(Util.edge(bgate) || retrigger) {
    state = 1;
    target = a_target * scale;
    step = a_step;
    retrigger = false;
  }
  
  while (i < nb) {
    
    n = n + 1;
    // only update if needed
    if (env_decimation_factor <= 1 || n % env_decimation_factor == 0) {
      
      // smooth level change
      if (level <> target_level) {
	level = level + level_step;
	// reached target
	if (
	    (level_step > 0.0 && level > target_level) ||
	    (level_step < 0.0 && level < target_level)
	    ) {
	  level = target_level;
	}
      }
      
      // idle, really nothing to do 
      if(state == 0) {
	out = 0.0;
      }
      else {
	idle = false;
	out = out + step; 
	
	// attack
	if(state == 1) {
	  // peaked, going to decay
	  if(out >=  target) {
	    step = d_step;
	    out = target;
	    target = s * scale;
	    state = 2;
	  }
	  // gate off, to go release
	  if (not(bgate)) {
	    step = stepToRelease(out*scale_i);
	    target = 0.0;
	    state = 4;
	  }
	}
	// decay
	if (state == 2) {
	  // gate off, to go release
	  if (not(bgate)) {
	    step = stepToRelease(out*scale_i);
	    target = 0.0;
	    state = 4;
	  }
	  // target reached, go to sustain
	  if (out <= target) {
	    out = target;
	    step = 0.0;
	    state = 3;
	  }
	  
	}
	// sustain
	if (state == 3) {
	  // just waiting for the gate to end, go to release
	  if (not(bgate)) {
	    step = r_step;
	    target = 0.0;
	    state = 4;
	  }
	}
	
	// release
	if(state == 4) {
	  // back to idle
	  if (out <= 0.0) {
	    out = 0.0;
	    state = 0;
	    step = 0.0;
	    target = 0.0;
	  }
	}
      }
    }
    
    oBuffer[i] = clip((out * scale_i)*level, 0.0, 1.0);
    i = i + 1;
  }
  return idle;
}

// once sample rate change, we need to adapt 
and updateSteps() {
   // to stay within fixed point limit we don't want the left part too big (target value as precise as the scale let it be, around 0.01 threshold), and the right part too big (too much time) -- rember limit [1/32767 .. 32767]
   // Note: because target will be scaled to 1000, compensate for sample rate in kHz
   // clip to min to make it work even without init
   val min_a, min_d, _, min_r = getMinValues(); 
   a_step = a_target / (fs * (clip(a, min_a, a)));
   // decay will go from 1 to sustain
   d_step = (s - a_target) / (fs * (clip(d, min_d, d)));
   // release from sustain to nothingness
   r_step = (- s) / (fs * (clip(r, min_r, r)));
}

// to be called internally, for smoothing changes in levels
and updateLevelStep() {
  // expects to go from 0 to 1 between levels in 3ms to avoid clicks -- albeit could counter lower attack in ADSR
  // TODO: leave that as on option ?
  level_step_ref = 1.0/(fs * 3.0);
}

// current sampling rate in kHz
and setSamplerate(newFs:real) {
  // keep aside sampling rate of the system
  mem real_fs;
  if (newFs > 0.0) {
     real_fs = newFs;
  }
   
  // alter used sampling rate considering decimation factor
  if (env_decimation_factor > 1) {
     fs = real_fs / real(env_decimation_factor);
  }
  else {
     fs = real_fs;
  }

  _ = updateSteps();
  _ = updateLevelStep();
}

// tradeoff between perfs (high decimation) and having smooth ADSR (no decimation)
// number should be a divisor of sample rate. Clip to max 1000, already well big enough (probably artifacts going beyond 5)
and setDecimationFactor(newFactor: int) {
  env_decimation_factor = clip(newFactor, 1, 1000);
  // actual sampling rate is linked to decimation, will update corresponding steps
  _ = setSamplerate(real_fs);
}

// set level of the output [0..1] (applied on the envelop)
// interpolate between levels
// NOTE: 0 level do not idle envelop because we consider that it could be modulated while running
and setLevel(newLevel: real) {
  target_level = clip(newLevel, 0.0, 1.0);
  if (target_level < level) {
    level_step = -level_step_ref;
  } else {
    level_step = level_step_ref;
  }
  // difference too tiny, just jump to level
  if (abs(target_level - level) <= level_step_ref) {
    level = target_level;
  }
}

// attack: time (s) to peak output at 1.0 -- limit to 60s (for fixed point sake)
// decay: time (s) to get to sustain level -- limit to 60s
// sustain: level when note is held (0..1)
// release: time (s) to get from sustain level to 0 -- limit to 60s
// Note: will set internally minimal value of 0.01, suitable for at least 10kHz
and config(newA, newD, newS, newR) {
   val max_a, max_d, max_s, max_r = getMaxValues(); 
   val min_a, min_d, min_s, min_r = getMinValues(); 
   // sanity check
   a =  clip(newA, min_a, max_a);
   d =  clip(newD, min_d, max_d);
   s =  clip(newS, min_s, max_s);
   r =  clip(newR, min_r, max_r);
   // so heavy computations
   _ = updateSteps();
}

// ask to retrigger upon next process
and retrig() {
  retrigger = true;
}

and default() @[init] {
   // Note: if fore some reason becomes < s, adapt decay to check if we reach sustain "from below" in process()
   mem a_target = 1.0;
   _ = setSamplerate(44.1);
   _ = config(0.0, 0.0, 0.5, 0.0);
   _ = setLevel(1.0);
   _ = setDecimationFactor(1);
}

// to let vult find above the good buffer size
fun dummy() {
   val buff;
   Buffer.buffer(buff);
   _ = process_bufferTo(false, 0, buff);
}
