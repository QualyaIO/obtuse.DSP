
// reading slices of samples for drums. Using linear interpolation to adjust for sampling rate and pitch.
// 12 slices, normal speed at C4-G5, then adjust each slice an octave up or down. Each new note replace immediately the previous one.

// TODO: kill on noteOff

fun process() {
  // absolutely needs init to set that
  mem size: int;
  // start and end positions for slices
  mem slices_start, slices_end;
  // current slice playing [0..11], out of bound to stop playing
  mem slice: int;
  // using integer "base position" float position to overcome limitation of fixed point
  mem posBase: int;
  mem pos: real;
  // how much we jump each step
  mem step: real;
  // we are velocity sensitive
  mem level: real;

  val value = 0.0;

  if (slice >= 0 && slice <= size(slices_start)) {

    // advance time, keep range in check here to maximize precision
    pos = pos + step;
    while (pos >= 1024.0) {
      posBase = posBase + 1024;
      pos = pos - 1024.0;
    }

    val idx = posBase + int(pos);
    // will stop and reset note once reach the end of file
    if (idx >= size) {
      slice = -1;
      posBase = 0;
      pos = 0.0;
    }

    // stop and reset once reached and of sample
    if (idx >= slices_end[slice]) {
      slice = -1;
      posBase = 0;
      pos = 0.0;
    } else {
      value = (DrummerWrapper.getSample(idx) + (pos % 1.0) * (DrummerWrapper.getSample(idx+1) - DrummerWrapper.getSample(idx))) * level;
    }

  }

  return value;
}


and process_bufferTo(nb: int, oBuffer) {
  nb = clip(nb, 0, size(oBuffer));
  if (nb == 0) {
     nb = size(oBuffer);
  }

  val value;
  val i = 0;

  while (i < nb) {
    value = 0.0;

    if (slice >= 0 && slice <= size(slices_start)) {
      // advance time, keep range in check here to maximize precision
      pos = pos + step;
      while (pos >= 1024.0) {
        posBase = posBase + 1024;
        pos = pos - 1024.0;
      }
  
      val idx = posBase + int(pos);
      // will stop and reset note once reach the end of file
      if (idx >= size) {
        slice = -1;
        posBase = 0;
        pos = 0.0;
      }

      // stop and reset once reached and of sample
      if (idx >= slices_end[slice]) {
        slice = -1;
        posBase = 0;
        pos = 0.0;
      } else {
        value = (DrummerWrapper.getSample(idx) + (pos % 1.0) * (DrummerWrapper.getSample(idx+1) - DrummerWrapper.getSample(idx))) * level;
      }
      
    }
    
    oBuffer[i] = value;
    i = i + 1;
  }
}

// retrocompatibility: using inner buffer
and process_buffer(nb: int) {
  mem buffer_o;
  _ = process_bufferTo(nb, buffer_o);
}

// called internally when Samplerate or note is altered
and updateStep() {
  // base for computing step
  mem noteRatio: real;
  mem fsRatio: real;
  // both for efficiency and because we don't want any result to be outside [1/32767 .. 32767] to avoid fixed float limits we compute step in two... steps
  step = noteRatio*fsRatio;
}

// passes start and stop arrays for slices. arrays must have same size, and same size as inner slices_start and slices_end arrays. For a slice to be updated indices must be within sample size range, and for each slice start pos must be before end pos.
and setSlices(newSlicesStart: array(int, 12), newSlicesEnd: array(int, 12)) {
  if (size(newSlicesStart) == size(newSlicesEnd) && size(newSlicesStart) == size(slices_start) && size(newSlicesEnd) == size(slices_end)) {
    val i = 0;
    val s, e;
    while (i < size(newSlicesStart)) {
      s = clip(newSlicesStart[i], 0, size - 1);
      e = clip(newSlicesEnd[i], 0, size - 1);
      if (s <= e) {
        slices_start[i] = s;
        slices_end[i] = e;
      }
      i = i + 1;
    }
  }
}

// seter for parameters. expect values of desired frequency and current sampling rate in kHz to avoid fixed float limits ([1/32767 ..32767]... probably)
and setSamplerate(newFs:real) {
  // sample rate of the recording
  mem sampleFs;
  // audio sampling rate
  mem fs: real;
   if (newFs > 0.0) {
      fs = newFs;
      // update ratio when we update sampling rate
      fsRatio = sampleFs/fs;
   }
   _ = updateStep();
}

// number of samples (note: valid once init)
and getSampleSize() {
  return size;
}

// set level of the output [0..1] (applied on the envelop)
and setLevel(newLevel: real) {
    level = newLevel;
}

// beginning of a note -- will effectively ignore duplicated noteOn for same note
// we don't check velocity, yet
and noteOn(note:int, velocity:int, channel:int){
  // only 128 midi notes
  note = clip(note, 0, 127);
  // root note for the 12 slices: C4
  val root = 60;
  slice = note % 12;
  // set starting position
  if (slice >= 0 && slice < size(slices_start)) {
    posBase = slices_start[slice];
    pos = 0.0;
  }

  // find octave compared to root note, 
  val slice_root = note - slice;
  // use ratio of note rather than freq to be more precise, +1 octave (12 semitones) doubles speed, -1 octave halves it
  val log_two = log10(2.0)/log10(exp(1.0)); // so that vultc replace with result of log(2)
  val octave = real(slice_root-root)/12.0;
  noteRatio = exp(log_two * octave);
  _ = updateStep();
  _ = setLevel(Util.velocityToLevel(velocity));
}

and noteOff(note:int, channel:int) {
}

and default() @[init] {
  size = DrummerWrapper.getSampleSize();
  // keep track of slices
  mem slices_start: array(int, 12);
  mem slices_end: array(int, 12);
  // defaults for current sample and DSP
  _ = setLevel(1.0);
  sampleFs = DrummerWrapper.getSampleFs();
  _ = setSamplerate(44.1);
  // set default slices
  _ = setSlices(DrummerWrapper.getSlicesStart(), DrummerWrapper.getSlicesEnd());
  // will copy a new array
  mem buffer_o;
  Buffer.buffer(buffer_o);
  // start with nothing
  slice = -1;
}

// to let vult find above the good buffer size
fun dummy() {
  val buff;
  Buffer.buffer(buff);
   _ = process_bufferTo(0, buff);
}
