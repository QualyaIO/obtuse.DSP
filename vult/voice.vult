
// wrapper to create voice from a poly synth
// Very conservative concerning the volume, will each voice will have a fraction of the max amplitude.
// Note: does not take midi channel into account at this level
// try to minimize (poorly) clicks when voices are stolen
// TODO: back to monophonic if number of voices is 1

// retrieve sample from all voices, mix
fun process() {
   // If voices are currently playng on not -- and max number of voices
   mem voices;
   // how many voices we support at the moment?
   mem number_voices;
   // store last values for each voice, used to avoid clicks when stealing one
   mem last_values;
   // keep all residues, that will decay over time to minimize clicks and pops (T60 200ms)
   mem leftovers: real;
   mem leftovers_decay: real;
   // to speedup, corresponding ratio per voice
   mem voices_ratio;
   // what voice (if any) number are associated to
   mem notes;
   // normalize: output maxed to -1 / 1 no matter the number of voices
   mem normalize;

   // output sample
   val value = 0.0;

   val i = 0;
   // accumulate all voices
   while (i < number_voices) {
      last_values[i] = poly:Poly.getSample(i);
      value = value + last_values[i];
      i = i + 1;
   }
   // leftovers, if any
   if (leftovers <> 0.0) {
       leftovers = leftovers * leftovers_decay;
       value = value + leftovers;
   }
   // normalise
   if (normalize) {
      return value * voices_ratio;
   }
   return value;
}

// one buffer for all voice
and process_bufferTo(nb: int, oBuffer: array(real, 256)) {
   // here used as temporary buffer to hold each voice
   mem buffer_v0;
   nb = clip(nb, 0, size(oBuffer));
   if (nb == 0) {
      nb = size(oBuffer);
   }
   // run all voices and add to output buffer
   val v = 0;
   val i = 0;
   // first run to init
   if (v < number_voices) {
      _ = poly:Poly.runVoice(v, nb, buffer_v0);
      i = 0;
      while (i < nb) {
         oBuffer[i] = buffer_v0[i];
         i = i + 1;
      }
      if (nb > 0) {
         last_values[v] = buffer_v0[nb - 1];
      }
      v = v + 1;
   }
   // accumulate the others
   while (v < number_voices) {
      _ = poly:Poly.runVoice(v, nb, buffer_v0);
      i = 0;
      while (i < nb) {
	oBuffer[i] = oBuffer[i] + buffer_v0[i];
         i = i + 1;
      }
      if (nb > 0) {
         last_values[v] = buffer_v0[nb - 1];
      }
      v = v + 1;
   }
   // leftovers, if any
   i = 0;
   while (leftovers <> 0.0 && i < nb) {
      leftovers = leftovers * leftovers_decay;
      oBuffer[i] = oBuffer[i] + leftovers;
      i = i + 1;
   }
   // scale down
   if (normalize) {
      i = 0;
      while (i < nb) {
          oBuffer[i] = oBuffer[i] * voices_ratio;
          i = i + 1;
      }
   }
}

// several buffer
// FIXME: only set for 4 voices
and process_bufferTo_alt(nb: int, oBuffer: array(real, 256)) {
   // temporary buffer to hold each voice
   mem buffer_v0, buffer_v1, buffer_v2, buffer_v3;
   nb = clip(nb, 0, size(oBuffer));
   if (nb == 0) {
      nb = size(oBuffer);
   }
   _ = poly:Poly.runVoice(0, nb, buffer_v0);
   _ = poly:Poly.runVoice(1, nb, buffer_v1);
   _ = poly:Poly.runVoice(2, nb, buffer_v2);
   _ = poly:Poly.runVoice(3, nb, buffer_v3);

   if (nb > 0) {
       last_values[0] = buffer_v0[nb - 1];
       last_values[1] = buffer_v1[nb - 1];
       last_values[2] = buffer_v2[nb - 1];
       last_values[3] = buffer_v3[nb - 1];
   }

   val i = 0;
   if (normalize) {
      while (i < nb) {
         oBuffer[i] = (buffer_v0[i] + buffer_v1[i] + buffer_v2[i] + buffer_v3[i]) * voices_ratio;
         i = i + 1;
      }
      // leftovers, if any
      i = 0;
      while (leftovers <> 0.0 && i < nb) {
         leftovers = leftovers * leftovers_decay;
         oBuffer[i] = oBuffer[i] + leftovers * voices_ratio;
         i = i + 1;
      }
   } else {
      while (i < nb) {
         oBuffer[i] = buffer_v0[i] + buffer_v1[i] + buffer_v2[i] + buffer_v3[i];
         i = i + 1;
      }
      // leftovers, if any
      i = 0;
      while (leftovers <> 0.0 && i < nb) {
         leftovers = leftovers * leftovers_decay;
         oBuffer[i] = oBuffer[i] + leftovers;
         i = i + 1;
      }

   }
}

// transmit noteOff to corresponding voice, update inner states active/inactive voice
and noteOff(note:int, channel:int) {
   // only 128 midi notes (and max voice)
   note = clip(note, 0, 127);
   // corresponding voice stored as voice+1
   val v = notes[note];
   // is this note really playing on a voice?
   if (v > 0 && v <= size(voices)) {
      // remove voice from active
      // channel 0, just because
      if (voicesactive:Notes.noteOff(v - 1, 0)) {
          // disable voice
          _ = poly:Poly.sendNoteOff(v - 1, note, channel);
          // update arrays
          notes[note] = 0;
	  voices[v-1] = 0;
	  // add voice to inactive (127 velocity, just because)
	  _ = voicesinactive:Notes.noteOn(v - 1, 127, 0);
      }
   }
}

// transmit noteOn to new voice (oldest inactive). If none, will turn off and steal oldest active. update inner states active/inactive voice
// note: pitch as MIDI code
// velocity: 0..127
// channnel: 1..16
and noteOn(note:int, velocity:int, channel:int){
   mem last_velocities;
   // only 128 midi notes
   note = clip(note, 0, 127);
   velocity = clip(velocity, 0, 127);
   // ignore note if already with a voice
   if (notes[note] <= 0) {
      // at least one free voice, take the oldest
      // todo: check both active and inactive status?
      val v = voicesinactive:Notes.firstNote();
      // no active voice, we will steal one
      if (v <= 0) {
         val active_v = voicesactive:Notes.firstNote();
	 // check we do indeed have one (the opposity would be a bug)
	 if (active_v > 0) {
	    // disable this voice (with arbitrary channel)
	    _ = noteOff(voices[active_v-1], 0);
	 }
      }
      // ne we should have at least one inactive voice
      v = voicesinactive:Notes.firstNote();
      if (v > 0) {
         // voice removed successfully from inactive ones and added to active ones (arbitrary channel 0 and velocity 127)
         if (voicesinactive:Notes.noteOff(v - 1, 0) && voicesactive:Notes.noteOn(v - 1, 127, 0)) {
            // retrieve last value of this voice to mitigate pops. If synth discourage this option (e.g. FM with simpler OSC waveform) then only take into account difference in levels if new note is at lower velocity
            if (poly:Poly.shouldLeftOvers()) {
               leftovers = leftovers + last_values[v-1];
            } else {
               val diff_velocity = last_velocities[v-1] - velocity;
               val diff_level = 0.0; 
               // only enable leftovers if new velocity is lower
               if (diff_velocity > 0) {
                  // velocity should be capped at 127
                  diff_level = real(diff_velocity) / 127.0;
               }
               leftovers = leftovers + last_values[v-1] * diff_level;
            }
	    // forward info
	    _ = poly:Poly.sendNoteOn(v - 1, note, velocity, channel);
            // update arrays
            notes[note] = v;
            voices[v-1] = note;
            last_velocities[v-1] = velocity;
         }
      }
   }
}

// setter for the number of voices, from 0 (disable) to max size of inner buffer
and setNbVoices(nbvoices: int) {
   nbvoices = clip(nbvoices, 0, size(voices));
   // turn off voices that will be unused, highest voice first
   val i = voicesactive:Notes.nbNotes();
   while(i > nbvoices && i > 0) {
      // get note of current voice and turn it off (with arbitrary channel)
      _ = noteOff(voices[i-1], 0);
      // also remove from inactive
      _ = voicesinactive:Notes.noteOff(i - 1, 0);
      i = i - 1;
   }
   // turn on inactive voice, lowest first
   i = voicesinactive:Notes.nbNotes();
   while(i < nbvoices) {
      _ = voicesinactive:Notes.noteOn(i, 127, 0);
      i = i + 1;
   }


   number_voices = nbvoices;
   voices_ratio  = 1.0/real(number_voices);
}

// normalize: output maxed to -1 / 1 no matter the number of voices
and setNormalize(flag: bool) {
   normalize = flag;
}

// change sampling rate for current synth
and setSamplerate(newFs:real) {
   mem fs;
   if (newFs > 0.0) {
      fs = newFs;
   }
   _ = poly:Poly.setSamplerate(fs);
   // safe formula as in reverb, to reduce by 60db leftovers in 200ms
   val log_base = log10(10.0)/log10(exp(1.0));
   leftovers_decay = exp(log_base * (-3.0 / 1000.0) / (fs * 0.2));
}

/* getter/setter passed down to synth, if supported */

// Sampler.setLoop()
and synthSetLoop(flag: bool) {
  _ =  poly:Poly.synthSetLoop(flag);
}

// Sampler.setLoopStart()
and synthSetLoopStart(value: int) {
  _ =  poly:Poly.synthSetLoopStart(value);
}

// Sampler.setLoopEnd()
and synthSetLoopEnd(value: int) {
  _ =  poly:Poly.synthSetLoopEnd(value);
}

// Sampler.getSampleSize()
and synthGetSize(): int {
  return poly:Poly.synthGetSize();
}

// FM: Wavetable.getNbWavetables()
and synthGetNbWavetables(): int {
  return poly:Poly.synthGetNbWavetables();
}

// FM: destined to modulator oscillator
and synthSetModulatorWavetable(wavetableIdx: real) {
  _ = poly:Poly.synthSetModulatorWavetable(wavetableIdx);
}

and synthSetModulatorWavetablePhase(phaseIdx: real) {
  _ = poly:Poly.synthSetModulatorWavetablePhase(phaseIdx);
}

// FM: destined to carrier oscillator
and synthSetCarrierWavetable(wavetableIdx: real) {
  _ = poly:Poly.synthSetCarrierWavetable(wavetableIdx);
}

and synthSetCarrierWavetablePhase(phaseIdx: real) {
  _ = poly:Poly.synthSetCarrierWavetablePhase(phaseIdx);
}

// FM.setModulatorRatio()
and synthSetModulatorRatio(ratio: real) {
  _ = poly:Poly.synthSetModulatorRatio(ratio);
}

// FM.setCarrierRatio()
and synthSetCarrierRatio(ratio: real) {
  _ = poly:Poly.synthSetCarrierRatio(ratio);
}

// FM.setModulatorLevel()
and synthSetModulatorLevel(level: real) {
  _ = poly:Poly.synthSetModulatorLevel(level);
}

// FM.setModulatorTargetLevel()
and synthSetModulatorTargetLevel(targetLevel: bool) {
  _ = poly:Poly.synthSetModulatorTargetLevel(targetLevel);
}

// FM.setModulatorPhaseShift
and synthSetModulatorPhaseShift(ratio: real) {
  _ = poly:Poly.synthSetModulatorPhaseShift(ratio);
}

// FM.setModulatorFeedback()
and synthSetModulatorFeedback(ratio: real) {
  _ = poly:Poly.synthSetModulatorFeedback(ratio);
}

// FM.setModulatorADSR()
and synthSetModulatorADSR(a:real , d: real, s: real, r: real) {
  _ = poly:Poly.synthSetModulatorADSR(a, d, s, r);
}

// FM.setCarrierADSR()
and synthSetCarrierADSR(a:real , d: real, s: real, r: real) {
  _ = poly:Poly.synthSetCarrierADSR(a, d, s, r);
}

/* end parameters for synths */

and default() @[init] {
   _ = poly:Poly.default();

   buffer_v0 = Util.buffer();
   buffer_v1 = Util.buffer();
   buffer_v2 = Util.buffer();
   buffer_v3 = Util.buffer();

   mem voices: array(int, 4);
   number_voices = if number_voices == 0 then size(voices) else number_voices;
    // which notes are active, if so to which voice? (to select voice and prune duplicated note on/off). Stores voice number + 1
   _ = setNbVoices(number_voices);
   mem notes: array(int, 128);
   // FIXME: hard-coded 4 voices
   mem last_values: array(real, 4);
   mem last_velocities: array(int, 4);

   // monophonic algo used to keep track of active voices...
   _ = voicesactive:Notes.default();
   _ = voicesactive:Notes.setPoly(false);
   // and same for disabled voices
   _ = voicesinactive:Notes.default();
   _ = voicesinactive:Notes.setPoly(false);

   _ = setNormalize(true);
   _ = setSamplerate(44.1);
}
