
// FM with 2 operators, phase modulation, monophonic

// TODO: should we reset phase on noteoff, keep processing with env 0?

// For future reference, note that using at least a temp variable in process() force vult to put that in cpp and halves computation times (???)


// giving wavetables to be used by both oscilator (tedious but this way we save on memory and copy in case of polyphony)
fun process(wavetable_modulator, wavetable_carrier) {
    // audio sampling rate
    mem fs: real;

    // pre-computed to speedup computations
    mem carrier_half_phase;
    mem carrier_phase_range;
    // used when target volume
    mem modulator_level_coeff;
    // shift modulator phase upon reset
    mem modulator_phase_shift: real;
    // feedback ratio applied to modulator
    mem modulator_half_phase: real;
    mem modulator_phase_range: real;

    // reduce cost of envelopes, only computes once in a while
    mem env_decimation_factor;
    mem carrier_env;
    mem modulator_env;
    // if we should modulate sound level instead of phase
    mem modulator_target_level: bool;
    // level of the synth, applied to envelop
    mem level;
    // number of iteration of this loop, for decimation
    mem n;

    //  current gate
    mem gate : bool;

    n = n + 1;
    val update_env:bool = true;
    if (env_decimation_factor > 0) {
       update_env = n % env_decimation_factor == 0;
    }

    // output value -- need to be explicitely initialized otherwise migth be random (?) producing audible clicks
    val carrier_val = 0.0;
    // retrieve envelopes -- both, to make sure that modulator gets updated
    if (update_env) {
       carrier_env = carrieradsr:ADSR.process(gate) * level;
       modulator_env = modulatoradsr:ADSR.process(gate);
    }

    // only going forward if we got sound on the output
    if (carrier_env > 0.0) {
       // modulate volume
       if (modulator_target_level) {
	 val carrier_level = 1.0;
	 if (modulator_env > 0.0) {
	   val modulator_val = modulator:OSC.process(wavetable_modulator) * modulator_env;
	   // modulator val will be -env .. env, shift to 0..2*env (max 0..2). Most efficient considering feedback needs envelope 
	   carrier_level = 1.0 - (modulator_val + modulator_env) *  modulator_level_coeff;
	   // apply feedback, if any
	   if (modulator_phase_range <> 0.0) {
             _ = modulator:OSC.setPhase(modulator_phase_shift + modulator_half_phase +  modulator_phase_range * modulator_val);
	   }
	 } else {
	   _ = modulator:OSC.resetPhase();
	   _ = modulator:OSC.setPhase(modulator_phase_shift);
	 }
	 carrier_val = carrier:OSC.process(wavetable_carrier) * carrier_env * carrier_level;
       }
       // modulate the (base) phase of the carrier
       else {
	 // apply to wavetables
	 val carrier_phase = 0.0;
	 // only modulate if we got level on modulator
	 if (modulator_env > 0.0) {
	   val modulator_val = modulator:OSC.process(wavetable_modulator) * modulator_env;
	   carrier_phase = carrier_half_phase + modulator_val * carrier_phase_range;
	   // apply feedback, if any
	   if (modulator_phase_range <> 0.0) {
             _ = modulator:OSC.setPhase(modulator_phase_shift + modulator_half_phase + modulator_phase_range * modulator_val);
	   }
	 } else {
	   _ = modulator:OSC.resetPhase();
	   _ = modulator:OSC.setPhase(modulator_phase_shift);
	 }
	 _ = carrier:OSC.setPhase(carrier_phase);
	 carrier_val = carrier:OSC.process(wavetable_carrier) * carrier_env ;
       }
    }
    // when an envelop ends we reset everything to make sure to start anew
    else {
      _ = carrier:OSC.resetPhase();
      if (modulator_env <= 0.0) {
        _ = modulator:OSC.resetPhase();
	_ = modulator:OSC.setPhase(modulator_phase_shift);
      }
    }

    return carrier_val;
}

// update the buffer, to be fetch afterward
and process_bufferTo(wavetable_modulator, wavetable_carrier, nb: int, oBuffer: array(real, 256)) {
    mem buffer_modulator;
    nb = clip(nb, 0, size(oBuffer));
    if (nb == 0) {
       nb = size(oBuffer);
    }
    // amount of phase modulation
    mem modulator_level;
    // amount of feedback
    mem modulator_feedback;
    // buffers for envelops, decimated and the full 
    mem buffer_carrier_env_short;
    mem buffer_modulator_env_short;
    mem buffer_carrier_env;
    mem buffer_modulator_env;

    // do we have any envelope?
    val env_modulator_idle = true;
    val env_carrier_idle = true;

    // sanitize env decimation
    val env_df = env_decimation_factor;
    if (env_df < 1) {
      env_df = 1;
    }
     
    if (env_decimation_factor > 1) {
      // compute number of samples for this buffer's decimation
      val nb_env = (n + nb) / env_decimation_factor;
      // retrieve envelopes
      if (nb_env > 0) {
         env_carrier_idle = carrieradsr:ADSR.process_bufferTo(gate, nb_env, buffer_carrier_env_short);
         env_modulator_idle = modulatoradsr:ADSR.process_bufferTo(gate, nb_env, buffer_modulator_env_short);

         // expand carrier envelop and retrieve to full version
         // FIXME: we update both envelopes, but we could select if only one is active
         val i = 0;
         val i_env = 0;
         while (i < nb) {
            // advance and update envelope
            n = (n + 1) % env_decimation_factor;
            if (n == 0) {
               modulator_env = buffer_modulator_env_short[i_env];
               carrier_env = buffer_carrier_env_short[i_env] * level;
               i_env = i_env + 1;
            }
            buffer_modulator_env[i] = modulator_env;
            buffer_carrier_env[i] = carrier_env;
            i = i + 1;
         }
      }
    } else {
       // no decimation, direct the whole buffer
       env_carrier_idle = carrieradsr:ADSR.process_bufferTo(gate, nb, buffer_carrier_env);
       env_modulator_idle = modulatoradsr:ADSR.process_bufferTo(gate, nb, buffer_modulator_env);
    }

    // apply to carrier
    if (env_carrier_idle) {
      // sync phase upon new envelopes -- albeit with a delay up to buffer size, compared to process()
      _ = carrier:OSC.resetPhase();
      if (env_modulator_idle) {
        _ = modulator:OSC.resetPhase();
	_ = modulator:OSC.setPhase(modulator_phase_shift);
      }
      // just silence on the output if its envelop is inactive
      val i = 0;
      while(i < nb) {
	oBuffer[i] = 0.0;
	i = i + 1;
      }

    } else {
      // zero modulation if inactive
      if (env_modulator_idle) {
        _ = modulator:OSC.resetPhase();
	_ = modulator:OSC.setPhase(modulator_phase_shift);
        val i = 0;
        while(i < nb) {
          buffer_modulator[i] = 0.0;
          i = i + 1;
        }
      } else {
	// feedback for modulator
	if (modulator_feedback <> 0.0) {
          _ = modulator:OSC.process_bufferTo_feedback(wavetable_modulator, nb, buffer_modulator_env, modulator_feedback, buffer_modulator);
	}
	// no feedback
	else {
          _ = modulator:OSC.process_bufferTo_simple(wavetable_modulator, nb, buffer_modulator_env, buffer_modulator);
	}
      }
      _ = carrier:OSC.process_bufferTo(wavetable_carrier, nb, buffer_carrier_env, buffer_modulator, buffer_modulator_env,  modulator_level, modulator_target_level, oBuffer);
    }
}
and setSamplerate(newFs:real) {
   if (newFs > 0.0) {
      fs = newFs;
   }
   _ = carrier:OSC.setSamplerate(fs);
   _ = modulator:OSC.setSamplerate(fs);

    // config for ADSR
    val ADSR_fs = fs;
    if (env_decimation_factor > 0) {
       ADSR_fs = fs / real(env_decimation_factor);
    }
    _ = carrieradsr:ADSR.setSamplerate(ADSR_fs);
    _ = modulatoradsr:ADSR.setSamplerate(ADSR_fs);
}
// ratio for each operator. Keep in mind the max effective frequency, below samplingrate/2!
// negative values: used a fixed frequency (in kHz) instead of a ratio (in which case the effect will be immediate)
and setCarrierRatio(ratio: real) {
   mem carrierRatio = ratio;
   if (carrierRatio < 0.0) {
      _ = carrier:OSC.setFrequency(-carrierRatio);
   }
}
and setModulatorRatio(ratio: real) {
   mem modulatorRatio = ratio;
   if (modulatorRatio < 0.0) {
      _ = modulator:OSC.setFrequency(-modulatorRatio);
   }
}
// effect of modulator [0..1]
and setModulatorLevel(newLevel: real) {
    modulator_level = newLevel;
    // directly manipulating the phase amount
    carrier_half_phase = real(carrier:OSC.getSize()) / 2.0;
    carrier_phase_range = carrier_half_phase * modulator_level;
    // will be used to change -1..1 to 0..1 range for modulating volume
    modulator_level_coeff = 0.5 * modulator_level;
}
// if modulator should modulate level or stay with phase
and setModulatorTargetLevel(targetLevel: bool) {
    modulator_target_level = targetLevel;
}
// ratio of phase shift for modulator (0..1)
and setModulatorPhaseShift(phaseRatio: real) {
  phaseRatio = clip(phaseRatio, 0.0, 1.0);
  modulator_phase_shift = modulator:OSC.getSize() * phaseRatio;
  modulator_phase_shift = modulator_phase_shift % modulator:OSC.getSize();
}
// feedback to modulator (should be 0..1)
and setModulatorFeedback(feedback: real) {
  modulator_feedback = feedback;
  // directly compute shift in samples
  modulator_half_phase = real(modulator:OSC.getSize()) / 2.0;
  modulator_phase_range = modulator_half_phase * feedback;
}
// set level of the output [0..1] (applied on the envelop)
and setLevel(newLevel: real) {
    level = newLevel;
}
// should be 0..nquist, in kHz
and setFrequency(freq: real) {
    if (carrierRatio >= 0.0) {
        _ = carrier:OSC.setFrequency(freq * carrierRatio);
    }
    if (modulatorRatio >= 0.0) {
        _ = modulator:OSC.setFrequency(freq * modulatorRatio);
    }
}

// set polpyphonic (true flag) or monophonic (false flag)
// monophonic: will get back to former notes, if any, upon note off
// polyphonic: does try to get back to held notes frequencies
and setPoly(flag: bool) {
   _ = playingnotes:Notes.setPoly(flag);
}

// midi-like interface

// beginning of a note -- will effectively ignore duplicated noteOn for same note
// we don't check velocity, yet
and noteOn(note:int, velocity:int, channel:int){
   // only 128 midi notes
   note = clip(note, 0, 127);
   // only acts if action taken into account
   if (playingnotes:Notes.noteOn(note, velocity, channel)) {
       // set frequency... should we reset phase somehow? artifacts upon first tests
       _ = setFrequency(Util.noteToFrequency(note));
       _ = setLevel(Util.velocityToLevel(velocity));
       // gate, no mater what
       gate = true;
   }
}
// note off whatever the channel, back to frequency of last still active note if any
and noteOff(note:int, channel:int) {
   // only 128 midi notes
   note = clip(note, 0, 127);
   // only acts if action taken into account
   if (playingnotes:Notes.noteOff(note, channel)) {
      // still gate on-going if there are note held, and switch to last
      if (playingnotes:Notes.nbNotes() > 0){
         val last_played = playingnotes:Notes.lastNote();
	 // check we do have a note -- and that it's in range
         if (last_played > 0 && last_played <= 128) {
	   // note: keeping current level...
            _ = setFrequency(Util.noteToFrequency(last_played - 1));
         }
      } else {
         gate = false;
      }
   }
}

// change oscillators envelopes
and setModulatorADSR(a, d, s, r) {
    _ = modulatoradsr:ADSR.config(a, d, s, r);
}

and setCarrierADSR(a, d, s, r) {
    _ = carrieradsr:ADSR.config(a, d, s, r);
}

// to be called on start
and default() @[init] {
    buffer_modulator = Util.buffer();
    buffer_carrier_env_short = Util.buffer();
    buffer_modulator_env_short = Util.buffer();
    buffer_carrier_env = Util.buffer();
    buffer_modulator_env = Util.buffer();

    // should be a divisor of sample rate
    env_decimation_factor = 3;

    // init used items
    // FIXME: not sure why if @init is set
    _ = carrier:OSC.default();
    _ = modulator:OSC.default();
    _ = carrieradsr:ADSR.default();
    _ = modulatoradsr:ADSR.default();

    // default envelops
    _ = setModulatorADSR(0.0, 0.0, 0.5, 0.0);
    _ = setCarrierADSR(0.0, 0.0, 0.5, 0.0);

    // default sampling rate (in kHz)
    _ = setSamplerate(44.100);
    
    // config for operators
    _ = setCarrierRatio(1.0);
    _ = setModulatorTargetLevel(false);
    _ = setModulatorRatio(2.0);
    _ = setModulatorLevel(0.1);
    _ = setLevel(1.0);
    // sarting with LA
    _ = setFrequency(0.440);

    // monophonic by default
    _ = playingnotes:Notes.default();
    _ = setPoly(false);
}
